/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { PLATFORM_ID, Inject, Injectable } from '@angular/core';
import { isPlatformServer } from '@angular/common';
import { setValue, getValue, InitState, UpdateState, actionMatcher } from '@ngxs/store';
import { tap } from 'rxjs/operators';
import { STORAGE_ENGINE, NGXS_STORAGE_PLUGIN_OPTIONS } from './symbols';
import { DEFAULT_STATE_KEY } from './internals';
var NgxsStoragePlugin = /** @class */ (function () {
    function NgxsStoragePlugin(_options, _engine, _platformId) {
        this._options = _options;
        this._engine = _engine;
        this._platformId = _platformId;
    }
    /**
     * @param {?} state
     * @param {?} event
     * @param {?} next
     * @return {?}
     */
    NgxsStoragePlugin.prototype.handle = /**
     * @param {?} state
     * @param {?} event
     * @param {?} next
     * @return {?}
     */
    function (state, event, next) {
        var _this = this;
        var e_1, _a;
        if (isPlatformServer(this._platformId) && this._engine === null) {
            return next(state, event);
        }
        // We cast to `string[]` here as we're sure that this option has been
        // transformed by the `storageOptionsFactory` function that provided token
        /** @type {?} */
        var keys = (/** @type {?} */ (this._options.key));
        /** @type {?} */
        var matches = actionMatcher(event);
        /** @type {?} */
        var isInitAction = matches(InitState);
        /** @type {?} */
        var isUpdateAction = matches(UpdateState);
        /** @type {?} */
        var isInitOrUpdateAction = isInitAction || isUpdateAction;
        /** @type {?} */
        var hasMigration = false;
        if (isInitOrUpdateAction) {
            var _loop_1 = function (key) {
                // We're checking what states have been added by NGXS and if any of these states should be handled by
                // the storage plugin. For instance, we only want to deserialize the `auth` state, NGXS has added
                // the `user` state, the storage plugin will be rerun and will do redundant deserialization.
                if (isUpdateAction && event.addedStates && !event.addedStates.hasOwnProperty(key)) {
                    return "continue";
                }
                /** @type {?} */
                var isMaster = key === DEFAULT_STATE_KEY;
                /** @type {?} */
                var val = this_1._engine.getItem((/** @type {?} */ (key)));
                if (val !== 'undefined' && val != null) {
                    try {
                        /** @type {?} */
                        var newVal = (/** @type {?} */ (this_1._options.deserialize))(val);
                        val = (/** @type {?} */ (this_1._options.afterDeserialize))(newVal, key);
                    }
                    catch (e) {
                        // Caretaker note: we have still left the `typeof` condition in order to avoid
                        // creating a breaking change for projects that still use the View Engine.
                        if (typeof ngDevMode === 'undefined' || ngDevMode) {
                            console.error("Error ocurred while deserializing the " + key + " store value, falling back to empty object, the value obtained from the store: ", val);
                        }
                        val = {};
                    }
                    if (this_1._options.migrations) {
                        this_1._options.migrations.forEach((/**
                         * @param {?} strategy
                         * @return {?}
                         */
                        function (strategy) {
                            /** @type {?} */
                            var versionMatch = strategy.version === getValue(val, strategy.versionKey || 'version');
                            /** @type {?} */
                            var keyMatch = (!strategy.key && isMaster) || strategy.key === key;
                            if (versionMatch && keyMatch) {
                                val = strategy.migrate(val);
                                hasMigration = true;
                            }
                        }));
                    }
                    if (!isMaster) {
                        state = setValue(state, (/** @type {?} */ (key)), val);
                    }
                    else {
                        state = tslib_1.__assign({}, state, val);
                    }
                }
            };
            var this_1 = this;
            try {
                for (var keys_1 = tslib_1.__values(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {
                    var key = keys_1_1.value;
                    _loop_1(key);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (keys_1_1 && !keys_1_1.done && (_a = keys_1.return)) _a.call(keys_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        return next(state, event).pipe(tap((/**
         * @param {?} nextState
         * @return {?}
         */
        function (nextState) {
            var e_2, _a;
            if (!isInitOrUpdateAction || (isInitOrUpdateAction && hasMigration)) {
                try {
                    for (var keys_2 = tslib_1.__values(keys), keys_2_1 = keys_2.next(); !keys_2_1.done; keys_2_1 = keys_2.next()) {
                        var key = keys_2_1.value;
                        /** @type {?} */
                        var val = nextState;
                        if (key !== DEFAULT_STATE_KEY) {
                            val = getValue(nextState, (/** @type {?} */ (key)));
                        }
                        try {
                            /** @type {?} */
                            var newVal = (/** @type {?} */ (_this._options.beforeSerialize))(val, key);
                            _this._engine.setItem((/** @type {?} */ (key)), (/** @type {?} */ (_this._options.serialize))(newVal));
                        }
                        catch (e) {
                            // Caretaker note: we have still left the `typeof` condition in order to avoid
                            // creating a breaking change for projects that still use the View Engine.
                            if (typeof ngDevMode === 'undefined' || ngDevMode) {
                                console.error("Error ocurred while serializing the " + key + " store value, value not updated, the value obtained from the store: ", val);
                            }
                        }
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (keys_2_1 && !keys_2_1.done && (_a = keys_2.return)) _a.call(keys_2);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            }
        })));
    };
    NgxsStoragePlugin.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    NgxsStoragePlugin.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: [NGXS_STORAGE_PLUGIN_OPTIONS,] }] },
        { type: undefined, decorators: [{ type: Inject, args: [STORAGE_ENGINE,] }] },
        { type: String, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }
    ]; };
    return NgxsStoragePlugin;
}());
export { NgxsStoragePlugin };
if (false) {
    /**
     * @type {?}
     * @private
     */
    NgxsStoragePlugin.prototype._options;
    /**
     * @type {?}
     * @private
     */
    NgxsStoragePlugin.prototype._engine;
    /**
     * @type {?}
     * @private
     */
    NgxsStoragePlugin.prototype._platformId;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RvcmFnZS5wbHVnaW4uanMiLCJzb3VyY2VSb290Ijoibmc6Ly9Abmd4cy9zdG9yYWdlLXBsdWdpbi8iLCJzb3VyY2VzIjpbInNyYy9zdG9yYWdlLnBsdWdpbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNoRSxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUNuRCxPQUFPLEVBRUwsUUFBUSxFQUNSLFFBQVEsRUFDUixTQUFTLEVBQ1QsV0FBVyxFQUNYLGFBQWEsRUFFZCxNQUFNLGFBQWEsQ0FBQztBQUNyQixPQUFPLEVBQUUsR0FBRyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFFckMsT0FBTyxFQUdMLGNBQWMsRUFDZCwyQkFBMkIsRUFDNUIsTUFBTSxXQUFXLENBQUM7QUFDbkIsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sYUFBYSxDQUFDO0FBUWhEO0lBRUUsMkJBQytDLFFBQWtDLEVBQy9DLE9BQXNCLEVBQ3pCLFdBQW1CO1FBRkgsYUFBUSxHQUFSLFFBQVEsQ0FBMEI7UUFDL0MsWUFBTyxHQUFQLE9BQU8sQ0FBZTtRQUN6QixnQkFBVyxHQUFYLFdBQVcsQ0FBUTtJQUMvQyxDQUFDOzs7Ozs7O0lBRUosa0NBQU07Ozs7OztJQUFOLFVBQU8sS0FBVSxFQUFFLEtBQVUsRUFBRSxJQUFzQjtRQUFyRCxpQkEwRkM7O1FBekZDLElBQUksZ0JBQWdCLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLElBQUksQ0FBQyxPQUFPLEtBQUssSUFBSSxFQUFFO1lBQy9ELE9BQU8sSUFBSSxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FBQztTQUMzQjs7OztZQUlLLElBQUksR0FBRyxtQkFBQSxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsRUFBWTs7WUFDcEMsT0FBTyxHQUFHLGFBQWEsQ0FBQyxLQUFLLENB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QVEsQ0FBQyxTQUFTLEVBQUUsbUJBQUEsR0FBRyxFQUFDLENBQUMsQ0FBQzt5QkFDakM7d0JBRUQsSUFBSTs7Z0NBQ0ksTUFBTSxHQUFHLG1CQUFBLEtBQUksQ0FBQyxRQUFRLENBQUMsZUFBZSxFQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQzs0QkFDdkQsS0FBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsbUJBQUEsR0FBRyxFQUFDLEVBQUUsbUJBQUEsS0FBSSxDQUFDLFFBQVEsQ0FBQyxTQUFTLEVBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO3lCQUM5RDt3QkFBQyxPQUFPLENBQUMsRUFBRTs0QkFDViw4RUFBOEU7NEJBQzlFLDBFQUEwRTs0QkFDMUUsSUFBSSxPQUFPLFNBQVMsS0FBSyxXQUFXLElBQUksU0FBUyxFQUFFO2dDQUNqRCxPQUFPLENBQUMsS0FBSyxDQUNYLHlDQUF1QyxHQUFHLHlFQUFzRSxFQUNoSCxHQUFHLENBQ0osQ0FBQzs2QkFDSDt5QkFDRjtxQkFDRjs7Ozs7Ozs7O2FBQ0Y7UUFDSCxDQUFDLEVBQUMsQ0FDSCxDQUFDO0lBQ0osQ0FBQzs7Z0JBbEdGLFVBQVU7Ozs7Z0RBR04sTUFBTSxTQUFDLDJCQUEyQjtnREFDbEMsTUFBTSxTQUFDLGNBQWM7NkNBQ3JCLE1BQU0sU0FBQyxXQUFXOztJQThGdkIsd0JBQUM7Q0FBQSxBQW5HRCxJQW1HQztTQWxHWSxpQkFBaUI7Ozs7OztJQUUxQixxQ0FBK0U7Ozs7O0lBQy9FLG9DQUFzRDs7Ozs7SUFDdEQsd0NBQWdEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUExBVEZPUk1fSUQsIEluamVjdCwgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBpc1BsYXRmb3JtU2VydmVyIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcclxuaW1wb3J0IHtcclxuICBOZ3hzUGx1Z2luLFxyXG4gIHNldFZhbHVlLFxyXG4gIGdldFZhbHVlLFxyXG4gIEluaXRTdGF0ZSxcclxuICBVcGRhdGVTdGF0ZSxcclxuICBhY3Rpb25NYXRjaGVyLFxyXG4gIE5neHNOZXh0UGx1Z2luRm5cclxufSBmcm9tICdAbmd4cy9zdG9yZSc7XHJcbmltcG9ydCB7IHRhcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcclxuXHJcbmltcG9ydCB7XHJcbiAgU3RvcmFnZUVuZ2luZSxcclxuICBOZ3hzU3RvcmFnZVBsdWdpbk9wdGlvbnMsXHJcbiAgU1RPUkFHRV9FTkdJTkUsXHJcbiAgTkdYU19TVE9SQUdFX1BMVUdJTl9PUFRJT05TXHJcbn0gZnJvbSAnLi9zeW1ib2xzJztcclxuaW1wb3J0IHsgREVGQVVMVF9TVEFURV9LRVkgfSBmcm9tICcuL2ludGVybmFscyc7XHJcblxyXG4vKipcclxuICogQGRlc2NyaXB0aW9uIFdpbGwgYmUgcHJvdmlkZWQgdGhyb3VnaCBUZXJzZXIgZ2xvYmFsIGRlZmluaXRpb25zIGJ5IEFuZ3VsYXIgQ0xJXHJcbiAqIGR1cmluZyB0aGUgcHJvZHVjdGlvbiBidWlsZC4gVGhpcyBpcyBob3cgQW5ndWxhciBkb2VzIHRyZWUtc2hha2luZyBpbnRlcm5hbGx5LlxyXG4gKi9cclxuZGVjbGFyZSBjb25zdCBuZ0Rldk1vZGU6IGJvb2xlYW47XHJcblxyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBjbGFzcyBOZ3hzU3RvcmFnZVBsdWdpbiBpbXBsZW1lbnRzIE5neHNQbHVnaW4ge1xyXG4gIGNvbnN0cnVjdG9yKFxyXG4gICAgQEluamVjdChOR1hTX1NUT1JBR0VfUExVR0lOX09QVElPTlMpIHByaXZhdGUgX29wdGlvbnM6IE5neHNTdG9yYWdlUGx1Z2luT3B0aW9ucyxcclxuICAgIEBJbmplY3QoU1RPUkFHRV9FTkdJTkUpIHByaXZhdGUgX2VuZ2luZTogU3RvcmFnZUVuZ2luZSxcclxuICAgIEBJbmplY3QoUExBVEZPUk1fSUQpIHByaXZhdGUgX3BsYXRmb3JtSWQ6IHN0cmluZ1xyXG4gICkge31cclxuXHJcbiAgaGFuZGxlKHN0YXRlOiBhbnksIGV2ZW50OiBhbnksIG5leHQ6IE5neHNOZXh0UGx1Z2luRm4pIHtcclxuICAgIGlmIChpc1BsYXRmb3JtU2VydmVyKHRoaXMuX3BsYXRmb3JtSWQpICYmIHRoaXMuX2VuZ2luZSA9PT0gbnVsbCkge1xyXG4gICAgICByZXR1cm4gbmV4dChzdGF0ZSwgZXZlbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFdlIGNhc3QgdG8gYHN0cmluZ1tdYCBoZXJlIGFzIHdlJ3JlIHN1cmUgdGhhdCB0aGlzIG9wdGlvbiBoYXMgYmVlblxyXG4gICAgLy8gdHJhbnNmb3JtZWQgYnkgdGhlIGBzdG9yYWdlT3B0aW9uc0ZhY3RvcnlgIGZ1bmN0aW9uIHRoYXQgcHJvdmlkZWQgdG9rZW5cclxuICAgIGNvbnN0IGtleXMgPSB0aGlzLl9vcHRpb25zLmtleSBhcyBzdHJpbmdbXTtcclxuICAgIGNvbnN0IG1hdGNoZXMgPSBhY3Rpb25NYXRjaGVyKGV2ZW50KTtcclxuICAgIGNvbnN0IGlzSW5pdEFjdGlvbiA9IG1hdGNoZXMoSW5pdFN0YXRlKTtcclxuICAgIGNvbnN0IGlzVXBkYXRlQWN0aW9uID0gbWF0Y2hlcyhVcGRhdGVTdGF0ZSk7XHJcbiAgICBjb25zdCBpc0luaXRPclVwZGF0ZUFjdGlvbiA9IGlzSW5pdEFjdGlvbiB8fCBpc1VwZGF0ZUFjdGlvbjtcclxuICAgIGxldCBoYXNNaWdyYXRpb24gPSBmYWxzZTtcclxuXHJcbiAgICBpZiAoaXNJbml0T3JVcGRhdGVBY3Rpb24pIHtcclxuICAgICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xyXG4gICAgICAgIC8vIFdlJ3JlIGNoZWNraW5nIHdoYXQgc3RhdGVzIGhhdmUgYmVlbiBhZGRlZCBieSBOR1hTIGFuZCBpZiBhbnkgb2YgdGhlc2Ugc3RhdGVzIHNob3VsZCBiZSBoYW5kbGVkIGJ5XHJcbiAgICAgICAgLy8gdGhlIHN0b3JhZ2UgcGx1Z2luLiBGb3IgaW5zdGFuY2UsIHdlIG9ubHkgd2FudCB0byBkZXNlcmlhbGl6ZSB0aGUgYGF1dGhgIHN0YXRlLCBOR1hTIGhhcyBhZGRlZFxyXG4gICAgICAgIC8vIHRoZSBgdXNlcmAgc3RhdGUsIHRoZSBzdG9yYWdlIHBsdWdpbiB3aWxsIGJlIHJlcnVuIGFuZCB3aWxsIGRvIHJlZHVuZGFudCBkZXNlcmlhbGl6YXRpb24uXHJcbiAgICAgICAgaWYgKGlzVXBkYXRlQWN0aW9uICYmIGV2ZW50LmFkZGVkU3RhdGVzICYmICFldmVudC5hZGRlZFN0YXRlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IGlzTWFzdGVyID0ga2V5ID09PSBERUZBVUxUX1NUQVRFX0tFWTtcclxuICAgICAgICBsZXQgdmFsOiBhbnkgPSB0aGlzLl9lbmdpbmUuZ2V0SXRlbShrZXkhKTtcclxuXHJcbiAgICAgICAgaWYgKHZhbCAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsICE9IG51bGwpIHtcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld1ZhbCA9IHRoaXMuX29wdGlvbnMuZGVzZXJpYWxpemUhKHZhbCk7XHJcbiAgICAgICAgICAgIHZhbCA9IHRoaXMuX29wdGlvbnMuYWZ0ZXJEZXNlcmlhbGl6ZSEobmV3VmFsLCBrZXkpO1xyXG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAvLyBDYXJldGFrZXIgbm90ZTogd2UgaGF2ZSBzdGlsbCBsZWZ0IHRoZSBgdHlwZW9mYCBjb25kaXRpb24gaW4gb3JkZXIgdG8gYXZvaWRcclxuICAgICAgICAgICAgLy8gY3JlYXRpbmcgYSBicmVha2luZyBjaGFuZ2UgZm9yIHByb2plY3RzIHRoYXQgc3RpbGwgdXNlIHRoZSBWaWV3IEVuZ2luZS5cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBuZ0Rldk1vZGUgPT09ICd1bmRlZmluZWQnIHx8IG5nRGV2TW9kZSkge1xyXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXHJcbiAgICAgICAgICAgICAgICBgRXJyb3Igb2N1cnJlZCB3aGlsZSBkZXNlcmlhbGl6aW5nIHRoZSAke2tleX0gc3RvcmUgdmFsdWUsIGZhbGxpbmcgYmFjayB0byBlbXB0eSBvYmplY3QsIHRoZSB2YWx1ZSBvYnRhaW5lZCBmcm9tIHRoZSBzdG9yZTogYCxcclxuICAgICAgICAgICAgICAgIHZhbFxyXG4gICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFsID0ge307XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMubWlncmF0aW9ucykge1xyXG4gICAgICAgICAgICB0aGlzLl9vcHRpb25zLm1pZ3JhdGlvbnMuZm9yRWFjaChzdHJhdGVneSA9PiB7XHJcbiAgICAgICAgICAgICAgY29uc3QgdmVyc2lvbk1hdGNoID1cclxuICAgICAgICAgICAgICAgIHN0cmF0ZWd5LnZlcnNpb24gPT09IGdldFZhbHVlKHZhbCwgc3RyYXRlZ3kudmVyc2lvbktleSB8fCAndmVyc2lvbicpO1xyXG4gICAgICAgICAgICAgIGNvbnN0IGtleU1hdGNoID0gKCFzdHJhdGVneS5rZXkgJiYgaXNNYXN0ZXIpIHx8IHN0cmF0ZWd5LmtleSA9PT0ga2V5O1xyXG4gICAgICAgICAgICAgIGlmICh2ZXJzaW9uTWF0Y2ggJiYga2V5TWF0Y2gpIHtcclxuICAgICAgICAgICAgICAgIHZhbCA9IHN0cmF0ZWd5Lm1pZ3JhdGUodmFsKTtcclxuICAgICAgICAgICAgICAgIGhhc01pZ3JhdGlvbiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBpZiAoIWlzTWFzdGVyKSB7XHJcbiAgICAgICAgICAgIHN0YXRlID0gc2V0VmFsdWUoc3RhdGUsIGtleSEsIHZhbCk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBzdGF0ZSA9IHsgLi4uc3RhdGUsIC4uLnZhbCB9O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBuZXh0KHN0YXRlLCBldmVudCkucGlwZShcclxuICAgICAgdGFwKG5leHRTdGF0ZSA9PiB7XHJcbiAgICAgICAgaWYgKCFpc0luaXRPclVwZGF0ZUFjdGlvbiB8fCAoaXNJbml0T3JVcGRhdGVBY3Rpb24gJiYgaGFzTWlncmF0aW9uKSkge1xyXG4gICAgICAgICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xyXG4gICAgICAgICAgICBsZXQgdmFsID0gbmV4dFN0YXRlO1xyXG5cclxuICAgICAgICAgICAgaWYgKGtleSAhPT0gREVGQVVMVF9TVEFURV9LRVkpIHtcclxuICAgICAgICAgICAgICB2YWwgPSBnZXRWYWx1ZShuZXh0U3RhdGUsIGtleSEpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgIGNvbnN0IG5ld1ZhbCA9IHRoaXMuX29wdGlvbnMuYmVmb3JlU2VyaWFsaXplISh2YWwsIGtleSk7XHJcbiAgICAgICAgICAgICAgdGhpcy5fZW5naW5lLnNldEl0ZW0oa2V5ISwgdGhpcy5fb3B0aW9ucy5zZXJpYWxpemUhKG5ld1ZhbCkpO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgLy8gQ2FyZXRha2VyIG5vdGU6IHdlIGhhdmUgc3RpbGwgbGVmdCB0aGUgYHR5cGVvZmAgY29uZGl0aW9uIGluIG9yZGVyIHRvIGF2b2lkXHJcbiAgICAgICAgICAgICAgLy8gY3JlYXRpbmcgYSBicmVha2luZyBjaGFuZ2UgZm9yIHByb2plY3RzIHRoYXQgc3RpbGwgdXNlIHRoZSBWaWV3IEVuZ2luZS5cclxuICAgICAgICAgICAgICBpZiAodHlwZW9mIG5nRGV2TW9kZSA9PT0gJ3VuZGVmaW5lZCcgfHwgbmdEZXZNb2RlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxyXG4gICAgICAgICAgICAgICAgICBgRXJyb3Igb2N1cnJlZCB3aGlsZSBzZXJpYWxpemluZyB0aGUgJHtrZXl9IHN0b3JlIHZhbHVlLCB2YWx1ZSBub3QgdXBkYXRlZCwgdGhlIHZhbHVlIG9idGFpbmVkIGZyb20gdGhlIHN0b3JlOiBgLFxyXG4gICAgICAgICAgICAgICAgICB2YWxcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9KVxyXG4gICAgKTtcclxuICB9XHJcbn1cclxuIl19