/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { PLATFORM_ID, Inject, Injectable } from '@angular/core';
import { isPlatformServer } from '@angular/common';
import { setValue, getValue, InitState, UpdateState, actionMatcher } from '@ngxs/store';
import { tap } from 'rxjs/operators';
import { STORAGE_ENGINE, NGXS_STORAGE_PLUGIN_OPTIONS } from './symbols';
import { DEFAULT_STATE_KEY } from './internals';
export class NgxsStoragePlugin {
    /**
     * @param {?} _options
     * @param {?} _engine
     * @param {?} _platformId
     */
    constructor(_options, _engine, _platformId) {
        this._options = _options;
        this._engine = _engine;
        this._platformId = _platformId;
    }
    /**
     * @param {?} state
     * @param {?} event
     * @param {?} next
     * @return {?}
     */
    handle(state, event, next) {
        if (isPlatformServer(this._platformId) && this._engine === null) {
            return next(state, event);
        }
        // We cast to `string[]` here as we're sure that this option has been
        // transformed by the `storageOptionsFactory` function that provided token
        /** @type {?} */
        const keys = (/** @type {?} */ (this._options.key));
        /** @type {?} */
        const matches = actionMatcher(event);
        /** @type {?} */
        const isInitAction = matches(InitState);
        /** @type {?} */
        const isUpdateAction = matches(UpdateState);
        /** @type {?} */
        const isInitOrUpdateAction = isInitAction || isUpdateAction;
        /** @type {?} */
        let hasMigration = false;
        if (isInitOrUpdateAction) {
            for (const key of keys) {
                // We're checking what states have been added by NGXS and if any of these states should be handled by
                // the storage plugin. For instance, we only want to deserialize the `auth` state, NGXS has added
                // the `user` state, the storage plugin will be rerun and will do redundant deserialization.
                if (isUpdateAction && event.addedStates && !event.addedStates.hasOwnProperty(key)) {
                    continue;
                }
                /** @type {?} */
                const isMaster = key === DEFAULT_STATE_KEY;
                /** @type {?} */
                let val = this._engine.getItem((/** @type {?} */ (key)));
                if (val !== 'undefined' && val != null) {
                    try {
                        /** @type {?} */
                        const newVal = (/** @type {?} */ (this._options.deserialize))(val);
                        val = (/** @type {?} */ (this._options.afterDeserialize))(newVal, key);
                    }
                    catch (e) {
                        // Caretaker note: we have still left the `typeof` condition in order to avoid
                        // creating a breaking change for projects that still use the View Engine.
                        if (typeof ngDevMode === 'undefined' || ngDevMode) {
                            console.error(`Error ocurred while deserializing the ${key} store value, falling back to empty object, the value obtained from the store: `, val);
                        }
                        val = {};
                    }
                    if (this._options.migrations) {
                        this._options.migrations.forEach((/**
                         * @param {?} strategy
                         * @return {?}
                         */
                        strategy => {
                            /** @type {?} */
                            const versionMatch = strategy.version === getValue(val, strategy.versionKey || 'version');
                            /** @type {?} */
                            const keyMatch = (!strategy.key && isMaster) || strategy.key === key;
                            if (versionMatch && keyMatch) {
                                val = strategy.migrate(val);
                                hasMigration = true;
                            }
                        }));
                    }
                    if (!isMaster) {
                        state = setValue(state, (/** @type {?} */ (key)), val);
                    }
                    else {
                        state = Object.assign({}, state, val);
                    }
                }
            }
        }
        return next(state, event).pipe(tap((/**
         * @param {?} nextState
         * @return {?}
         */
        nextState => {
            if (!isInitOrUpdateAction || (isInitOrUpdateAction && hasMigration)) {
                for (const key of keys) {
                    /** @type {?} */
                    let val = nextState;
                    if (key !== DEFAULT_STATE_KEY) {
                        val = getValue(nextState, (/** @type {?} */ (key)));
                    }
                    try {
                        /** @type {?} */
                        const newVal = (/** @type {?} */ (this._options.beforeSerialize))(val, key);
                        this._engine.setItem((/** @type {?} */ (key)), (/** @type {?} */ (this._options.serialize))(newVal));
                    }
                    catch (e) {
                        // Caretaker note: we have still left the `typeof` condition in order to avoid
                        // creating a breaking change for projects that still use the View Engine.
                        if (typeof ngDevMode === 'undefined' || ngDevMode) {
                            console.error(`Error ocurred while serializing the ${key} store value, value not updated, the value obtained from the store: `, val);
                        }
                    }
                }
            }
        })));
    }
}
NgxsStoragePlugin.decorators = [
    { type: Injectable }
];
/** @nocollapse */
NgxsStoragePlugin.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [NGXS_STORAGE_PLUGIN_OPTIONS,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [STORAGE_ENGINE,] }] },
    { type: String, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }
];
if (false) {
    /**
     * @type {?}
     * @private
     */
    NgxsStoragePlugin.prototype._options;
    /**
     * @type {?}
     * @private
     */
    NgxsStoragePlugin.prototype._engine;
    /**
     * @type {?}
     * @private
     */
    NgxsStoragePlugin.prototype._platformId;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RvcmFnZS5wbHVnaW4uanMiLCJzb3VyY2VSb290Ijoibmc6Ly9Abmd4cy9zdG9yYWdlLXBsdWdpbi8iLCJzb3VyY2VzIjpbInNyYy9zdG9yYWdlLnBsdWdpbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ2hFLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQ25ELE9BQU8sRUFFTCxRQUFRLEVBQ1IsUUFBUSxFQUNSLFNBQVMsRUFDVCxXQUFXLEVBQ1gsYUFBYSxFQUVkLE1BQU0sYUFBYSxDQUFDO0FBQ3JCLE9BQU8sRUFBRSxHQUFHLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUVyQyxPQUFPLEVBR0wsY0FBYyxFQUNkLDJCQUEyQixFQUM1QixNQUFNLFdBQVcsQ0FBQztBQUNuQixPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxhQUFhLENBQUM7QUFTaEQsTUFBTSxPQUFPLGlCQUFpQjs7Ozs7O0lBQzVCLFlBQytDLFFBQWtDLEVBQy9DLE9BQXNCLEVBQ3pCLFdBQW1CO1FBRkgsYUFBUSxHQUFSLFFBQVEsQ0FBMEI7UUFDL0MsWUFBTyxHQUFQLE9BQU8sQ0FBZTtRQUN6QixnQkFBVyxHQUFYLFdBQVcsQ0FBUTtJQUMvQyxDQUFDOzs7Ozs7O0lBRUosTUFBTSxDQUFDLEtBQVUsRUFBRSxLQUFVLEVBQUUsSUFBc0I7UUFDbkQsSUFBSSxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksSUFBSSxDQUFDLE9BQU8sS0FBSyxJQUFJLEVBQUU7WUFDL0QsT0FBTyxJQUFJLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFDO1NBQzNCOzs7O2NBSUssSUFBSSxHQUFHLG1CQUFBLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFZOztjQUNwQyxPQUFPLEdBQUcsYUFBYSxDQUFDLEtBQUssQ0FBQzs7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TSxHQUFHLG1CQUFBLElBQUksQ0FBQyxRQUFRLENBQUMsZUFBZSxFQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQzt3QkFDdkQsSUFBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsbUJBQUEsR0FBRyxFQUFDLEVBQUUsbUJBQUEsSUFBSSxDQUFDLFFBQVEsQ0FBQyxTQUFTLEVBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO3FCQUM5RDtvQkFBQyxPQUFPLENBQUMsRUFBRTt3QkFDViw4RUFBOEU7d0JBQzlFLDBFQUEwRTt3QkFDMUUsSUFBSSxPQUFPLFNBQVMsS0FBSyxXQUFXLElBQUksU0FBUyxFQUFFOzRCQUNqRCxPQUFPLENBQUMsS0FBSyxDQUNYLHVDQUF1QyxHQUFHLHNFQUFzRSxFQUNoSCxHQUFHLENBQ0osQ0FBQzt5QkFDSDtxQkFDRjtpQkFDRjthQUNGO1FBQ0gsQ0FBQyxFQUFDLENBQ0gsQ0FBQztJQUNKLENBQUM7OztZQWxHRixVQUFVOzs7OzRDQUdOLE1BQU0sU0FBQywyQkFBMkI7NENBQ2xDLE1BQU0sU0FBQyxjQUFjO3lDQUNyQixNQUFNLFNBQUMsV0FBVzs7Ozs7OztJQUZuQixxQ0FBK0U7Ozs7O0lBQy9FLG9DQUFzRDs7Ozs7SUFDdEQsd0NBQWdEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUExBVEZPUk1fSUQsIEluamVjdCwgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBpc1BsYXRmb3JtU2VydmVyIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcclxuaW1wb3J0IHtcclxuICBOZ3hzUGx1Z2luLFxyXG4gIHNldFZhbHVlLFxyXG4gIGdldFZhbHVlLFxyXG4gIEluaXRTdGF0ZSxcclxuICBVcGRhdGVTdGF0ZSxcclxuICBhY3Rpb25NYXRjaGVyLFxyXG4gIE5neHNOZXh0UGx1Z2luRm5cclxufSBmcm9tICdAbmd4cy9zdG9yZSc7XHJcbmltcG9ydCB7IHRhcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcclxuXHJcbmltcG9ydCB7XHJcbiAgU3RvcmFnZUVuZ2luZSxcclxuICBOZ3hzU3RvcmFnZVBsdWdpbk9wdGlvbnMsXHJcbiAgU1RPUkFHRV9FTkdJTkUsXHJcbiAgTkdYU19TVE9SQUdFX1BMVUdJTl9PUFRJT05TXHJcbn0gZnJvbSAnLi9zeW1ib2xzJztcclxuaW1wb3J0IHsgREVGQVVMVF9TVEFURV9LRVkgfSBmcm9tICcuL2ludGVybmFscyc7XHJcblxyXG4vKipcclxuICogQGRlc2NyaXB0aW9uIFdpbGwgYmUgcHJvdmlkZWQgdGhyb3VnaCBUZXJzZXIgZ2xvYmFsIGRlZmluaXRpb25zIGJ5IEFuZ3VsYXIgQ0xJXHJcbiAqIGR1cmluZyB0aGUgcHJvZHVjdGlvbiBidWlsZC4gVGhpcyBpcyBob3cgQW5ndWxhciBkb2VzIHRyZWUtc2hha2luZyBpbnRlcm5hbGx5LlxyXG4gKi9cclxuZGVjbGFyZSBjb25zdCBuZ0Rldk1vZGU6IGJvb2xlYW47XHJcblxyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBjbGFzcyBOZ3hzU3RvcmFnZVBsdWdpbiBpbXBsZW1lbnRzIE5neHNQbHVnaW4ge1xyXG4gIGNvbnN0cnVjdG9yKFxyXG4gICAgQEluamVjdChOR1hTX1NUT1JBR0VfUExVR0lOX09QVElPTlMpIHByaXZhdGUgX29wdGlvbnM6IE5neHNTdG9yYWdlUGx1Z2luT3B0aW9ucyxcclxuICAgIEBJbmplY3QoU1RPUkFHRV9FTkdJTkUpIHByaXZhdGUgX2VuZ2luZTogU3RvcmFnZUVuZ2luZSxcclxuICAgIEBJbmplY3QoUExBVEZPUk1fSUQpIHByaXZhdGUgX3BsYXRmb3JtSWQ6IHN0cmluZ1xyXG4gICkge31cclxuXHJcbiAgaGFuZGxlKHN0YXRlOiBhbnksIGV2ZW50OiBhbnksIG5leHQ6IE5neHNOZXh0UGx1Z2luRm4pIHtcclxuICAgIGlmIChpc1BsYXRmb3JtU2VydmVyKHRoaXMuX3BsYXRmb3JtSWQpICYmIHRoaXMuX2VuZ2luZSA9PT0gbnVsbCkge1xyXG4gICAgICByZXR1cm4gbmV4dChzdGF0ZSwgZXZlbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFdlIGNhc3QgdG8gYHN0cmluZ1tdYCBoZXJlIGFzIHdlJ3JlIHN1cmUgdGhhdCB0aGlzIG9wdGlvbiBoYXMgYmVlblxyXG4gICAgLy8gdHJhbnNmb3JtZWQgYnkgdGhlIGBzdG9yYWdlT3B0aW9uc0ZhY3RvcnlgIGZ1bmN0aW9uIHRoYXQgcHJvdmlkZWQgdG9rZW5cclxuICAgIGNvbnN0IGtleXMgPSB0aGlzLl9vcHRpb25zLmtleSBhcyBzdHJpbmdbXTtcclxuICAgIGNvbnN0IG1hdGNoZXMgPSBhY3Rpb25NYXRjaGVyKGV2ZW50KTtcclxuICAgIGNvbnN0IGlzSW5pdEFjdGlvbiA9IG1hdGNoZXMoSW5pdFN0YXRlKTtcclxuICAgIGNvbnN0IGlzVXBkYXRlQWN0aW9uID0gbWF0Y2hlcyhVcGRhdGVTdGF0ZSk7XHJcbiAgICBjb25zdCBpc0luaXRPclVwZGF0ZUFjdGlvbiA9IGlzSW5pdEFjdGlvbiB8fCBpc1VwZGF0ZUFjdGlvbjtcclxuICAgIGxldCBoYXNNaWdyYXRpb24gPSBmYWxzZTtcclxuXHJcbiAgICBpZiAoaXNJbml0T3JVcGRhdGVBY3Rpb24pIHtcclxuICAgICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xyXG4gICAgICAgIC8vIFdlJ3JlIGNoZWNraW5nIHdoYXQgc3RhdGVzIGhhdmUgYmVlbiBhZGRlZCBieSBOR1hTIGFuZCBpZiBhbnkgb2YgdGhlc2Ugc3RhdGVzIHNob3VsZCBiZSBoYW5kbGVkIGJ5XHJcbiAgICAgICAgLy8gdGhlIHN0b3JhZ2UgcGx1Z2luLiBGb3IgaW5zdGFuY2UsIHdlIG9ubHkgd2FudCB0byBkZXNlcmlhbGl6ZSB0aGUgYGF1dGhgIHN0YXRlLCBOR1hTIGhhcyBhZGRlZFxyXG4gICAgICAgIC8vIHRoZSBgdXNlcmAgc3RhdGUsIHRoZSBzdG9yYWdlIHBsdWdpbiB3aWxsIGJlIHJlcnVuIGFuZCB3aWxsIGRvIHJlZHVuZGFudCBkZXNlcmlhbGl6YXRpb24uXHJcbiAgICAgICAgaWYgKGlzVXBkYXRlQWN0aW9uICYmIGV2ZW50LmFkZGVkU3RhdGVzICYmICFldmVudC5hZGRlZFN0YXRlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IGlzTWFzdGVyID0ga2V5ID09PSBERUZBVUxUX1NUQVRFX0tFWTtcclxuICAgICAgICBsZXQgdmFsOiBhbnkgPSB0aGlzLl9lbmdpbmUuZ2V0SXRlbShrZXkhKTtcclxuXHJcbiAgICAgICAgaWYgKHZhbCAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsICE9IG51bGwpIHtcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld1ZhbCA9IHRoaXMuX29wdGlvbnMuZGVzZXJpYWxpemUhKHZhbCk7XHJcbiAgICAgICAgICAgIHZhbCA9IHRoaXMuX29wdGlvbnMuYWZ0ZXJEZXNlcmlhbGl6ZSEobmV3VmFsLCBrZXkpO1xyXG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAvLyBDYXJldGFrZXIgbm90ZTogd2UgaGF2ZSBzdGlsbCBsZWZ0IHRoZSBgdHlwZW9mYCBjb25kaXRpb24gaW4gb3JkZXIgdG8gYXZvaWRcclxuICAgICAgICAgICAgLy8gY3JlYXRpbmcgYSBicmVha2luZyBjaGFuZ2UgZm9yIHByb2plY3RzIHRoYXQgc3RpbGwgdXNlIHRoZSBWaWV3IEVuZ2luZS5cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBuZ0Rldk1vZGUgPT09ICd1bmRlZmluZWQnIHx8IG5nRGV2TW9kZSkge1xyXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXHJcbiAgICAgICAgICAgICAgICBgRXJyb3Igb2N1cnJlZCB3aGlsZSBkZXNlcmlhbGl6aW5nIHRoZSAke2tleX0gc3RvcmUgdmFsdWUsIGZhbGxpbmcgYmFjayB0byBlbXB0eSBvYmplY3QsIHRoZSB2YWx1ZSBvYnRhaW5lZCBmcm9tIHRoZSBzdG9yZTogYCxcclxuICAgICAgICAgICAgICAgIHZhbFxyXG4gICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFsID0ge307XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMubWlncmF0aW9ucykge1xyXG4gICAgICAgICAgICB0aGlzLl9vcHRpb25zLm1pZ3JhdGlvbnMuZm9yRWFjaChzdHJhdGVneSA9PiB7XHJcbiAgICAgICAgICAgICAgY29uc3QgdmVyc2lvbk1hdGNoID1cclxuICAgICAgICAgICAgICAgIHN0cmF0ZWd5LnZlcnNpb24gPT09IGdldFZhbHVlKHZhbCwgc3RyYXRlZ3kudmVyc2lvbktleSB8fCAndmVyc2lvbicpO1xyXG4gICAgICAgICAgICAgIGNvbnN0IGtleU1hdGNoID0gKCFzdHJhdGVneS5rZXkgJiYgaXNNYXN0ZXIpIHx8IHN0cmF0ZWd5LmtleSA9PT0ga2V5O1xyXG4gICAgICAgICAgICAgIGlmICh2ZXJzaW9uTWF0Y2ggJiYga2V5TWF0Y2gpIHtcclxuICAgICAgICAgICAgICAgIHZhbCA9IHN0cmF0ZWd5Lm1pZ3JhdGUodmFsKTtcclxuICAgICAgICAgICAgICAgIGhhc01pZ3JhdGlvbiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBpZiAoIWlzTWFzdGVyKSB7XHJcbiAgICAgICAgICAgIHN0YXRlID0gc2V0VmFsdWUoc3RhdGUsIGtleSEsIHZhbCk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBzdGF0ZSA9IHsgLi4uc3RhdGUsIC4uLnZhbCB9O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBuZXh0KHN0YXRlLCBldmVudCkucGlwZShcclxuICAgICAgdGFwKG5leHRTdGF0ZSA9PiB7XHJcbiAgICAgICAgaWYgKCFpc0luaXRPclVwZGF0ZUFjdGlvbiB8fCAoaXNJbml0T3JVcGRhdGVBY3Rpb24gJiYgaGFzTWlncmF0aW9uKSkge1xyXG4gICAgICAgICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xyXG4gICAgICAgICAgICBsZXQgdmFsID0gbmV4dFN0YXRlO1xyXG5cclxuICAgICAgICAgICAgaWYgKGtleSAhPT0gREVGQVVMVF9TVEFURV9LRVkpIHtcclxuICAgICAgICAgICAgICB2YWwgPSBnZXRWYWx1ZShuZXh0U3RhdGUsIGtleSEpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgIGNvbnN0IG5ld1ZhbCA9IHRoaXMuX29wdGlvbnMuYmVmb3JlU2VyaWFsaXplISh2YWwsIGtleSk7XHJcbiAgICAgICAgICAgICAgdGhpcy5fZW5naW5lLnNldEl0ZW0oa2V5ISwgdGhpcy5fb3B0aW9ucy5zZXJpYWxpemUhKG5ld1ZhbCkpO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgLy8gQ2FyZXRha2VyIG5vdGU6IHdlIGhhdmUgc3RpbGwgbGVmdCB0aGUgYHR5cGVvZmAgY29uZGl0aW9uIGluIG9yZGVyIHRvIGF2b2lkXHJcbiAgICAgICAgICAgICAgLy8gY3JlYXRpbmcgYSBicmVha2luZyBjaGFuZ2UgZm9yIHByb2plY3RzIHRoYXQgc3RpbGwgdXNlIHRoZSBWaWV3IEVuZ2luZS5cclxuICAgICAgICAgICAgICBpZiAodHlwZW9mIG5nRGV2TW9kZSA9PT0gJ3VuZGVmaW5lZCcgfHwgbmdEZXZNb2RlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxyXG4gICAgICAgICAgICAgICAgICBgRXJyb3Igb2N1cnJlZCB3aGlsZSBzZXJpYWxpemluZyB0aGUgJHtrZXl9IHN0b3JlIHZhbHVlLCB2YWx1ZSBub3QgdXBkYXRlZCwgdGhlIHZhbHVlIG9idGFpbmVkIGZyb20gdGhlIHN0b3JlOiBgLFxyXG4gICAgICAgICAgICAgICAgICB2YWxcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9KVxyXG4gICAgKTtcclxuICB9XHJcbn1cclxuIl19