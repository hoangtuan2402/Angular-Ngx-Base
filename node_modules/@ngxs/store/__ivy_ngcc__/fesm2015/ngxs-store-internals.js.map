{"version":3,"file":"ngxs-store-internals.js","sources":["@ngxs/store/internals/angular.ts","@ngxs/store/internals/ngxs-bootstrapper.ts","@ngxs/store/internals/memoize.ts","@ngxs/store/internals/initial-state.ts","@ngxs/store/internals/internal-tokens.ts","@ngxs/store/internals/decorator-injector-adapter.ts"],"names":[],"mappings":"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","sourcesContent":["declare const __karma__: unknown;\r\ndeclare const jasmine: unknown;\r\ndeclare const jest: unknown;\r\ndeclare const Mocha: unknown;\r\n\r\nexport function isAngularInTestMode(): boolean {\r\n  // This is safe to check for these properties in the following way since `typeof` does not\r\n  // throw an exception if the value does not exist in the scope.\r\n  // We should not try to read these values from the global scope (e.g. `Éµglobal` from the `@angular/core`).\r\n  // This is related to how these frameworks compile and execute modules. E.g. Jest wraps the module into\r\n  // its internal code where `jest` variable exists in the scope. It cannot be read from the global scope, e.g.\r\n  // this will return undefined `global.jest`, but `jest` will not equal undefined.\r\n  return (\r\n    typeof __karma__ !== 'undefined' ||\r\n    typeof jasmine !== 'undefined' ||\r\n    typeof jest !== 'undefined' ||\r\n    typeof Mocha !== 'undefined'\r\n  );\r\n}\r\n","import { Injectable } from '@angular/core';\r\nimport { Observable, ReplaySubject } from 'rxjs';\r\n\r\n@Injectable()\r\nexport class NgxsBootstrapper {\r\n  /**\r\n   * Use `ReplaySubject`, thus we can get cached value even if the stream is completed\r\n   */\r\n  private bootstrap$ = new ReplaySubject<boolean>(1);\r\n\r\n  get appBootstrapped$(): Observable<boolean> {\r\n    return this.bootstrap$.asObservable();\r\n  }\r\n\r\n  /**\r\n   * This event will be emitted after attaching `ComponentRef` of the root component\r\n   * to the tree of views, that's a signal that application has been fully rendered\r\n   */\r\n  bootstrap(): void {\r\n    this.bootstrap$.next(true);\r\n    this.bootstrap$.complete();\r\n  }\r\n}\r\n","function defaultEqualityCheck(a: any, b: any) {\r\n  return a === b;\r\n}\r\n\r\nfunction areArgumentsShallowlyEqual(\r\n  equalityCheck: (a: any, b: any) => boolean,\r\n  prev: IArguments | null,\r\n  next: IArguments | null\r\n) {\r\n  if (prev === null || next === null || prev.length !== next.length) {\r\n    return false;\r\n  }\r\n\r\n  // Do this in a for loop (and not a `forEach` or an `every`) so we can determine equality as fast as possible.\r\n  const length = prev.length;\r\n  for (let i = 0; i < length; i++) {\r\n    if (!equalityCheck(prev[i], next[i])) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\n/**\r\n * Memoize a function on its last inputs only.\r\n * Originally from: https://github.com/reduxjs/reselect/blob/master/src/index.js\r\n *\r\n * @ignore\r\n */\r\nexport function memoize<T extends (...args: any[]) => any>(\r\n  func: T,\r\n  equalityCheck = defaultEqualityCheck\r\n): T {\r\n  let lastArgs: IArguments | null = null;\r\n  let lastResult: any = null;\r\n  // we reference arguments instead of spreading them for performance reasons\r\n  function memoized() {\r\n    if (!areArgumentsShallowlyEqual(equalityCheck, lastArgs, arguments)) {\r\n      // apply arguments instead of spreading for performance.\r\n      lastResult = (<Function>func).apply(null, arguments);\r\n    }\r\n\r\n    lastArgs = arguments;\r\n    return lastResult;\r\n  }\r\n  (<any>memoized).reset = function() {\r\n    // The hidden (for now) ability to reset the memoization\r\n    lastArgs = null;\r\n    lastResult = null;\r\n  };\r\n  return memoized as T;\r\n}\r\n","import { InjectionToken } from '@angular/core';\r\nimport { PlainObject } from './symbols';\r\n\r\nexport const INITIAL_STATE_TOKEN = new InjectionToken<any>('INITIAL_STATE_TOKEN');\r\n\r\nexport class InitialState {\r\n  private static value: PlainObject = {};\r\n\r\n  public static set(state: PlainObject) {\r\n    this.value = state;\r\n  }\r\n\r\n  public static pop(): PlainObject {\r\n    const state: PlainObject = this.value;\r\n    this.value = {};\r\n    return state;\r\n  }\r\n}\r\n","import { InjectionToken } from '@angular/core';\r\n\r\n/**\r\n * @see StateContextFactory as it's referenced by this token to be accessed by plugins internally\r\n */\r\nexport const NGXS_STATE_CONTEXT_FACTORY: InjectionToken<any> = new InjectionToken(\r\n  'Internals.StateContextFactory'\r\n);\r\n\r\n/**\r\n * @see StateFactory as it's referenced by this token to be accessed by plugins internally\r\n */\r\nexport const NGXS_STATE_FACTORY: InjectionToken<any> = new InjectionToken(\r\n  'Internals.StateFactory'\r\n);\r\n","import {\r\n  InjectionToken,\r\n  Injector,\r\n  INJECTOR,\r\n  Type,\r\n  ÉµÉµdirectiveInject,\r\n  Éµglobal\r\n} from '@angular/core';\r\nimport { ReplaySubject } from 'rxjs';\r\n\r\n// Will be provided through Terser global definitions by Angular CLI\r\n// during the production build. This is how Angular does tree-shaking internally.\r\ndeclare const ngDevMode: boolean;\r\n\r\n// Angular doesn't export `NG_FACTORY_DEF`.\r\nconst NG_FACTORY_DEF = 'Éµfac';\r\n\r\n// A `Symbol` which is used to save the `Injector` onto the class instance.\r\nconst InjectorInstance: unique symbol = Symbol('InjectorInstance');\r\n\r\n// A `Symbol` which is used to determine if factory has been decorated previously or not.\r\nconst FactoryHasBeenDecorated: unique symbol = Symbol('FactoryHasBeenDecorated');\r\n\r\n// A `Symbol` which is used to save the notifier on the class instance. The `InjectorInstance` cannot\r\n// be retrieved within the `constructor` since it's set after the `factory()` is called.\r\nconst InjectorNotifier: unique symbol = Symbol('InjectorNotifier');\r\n\r\ninterface PrototypeWithInjectorNotifier extends Object {\r\n  [InjectorNotifier]?: ReplaySubject<boolean>;\r\n}\r\n\r\nexport function ensureInjectorNotifierIsCaptured(\r\n  target: PrototypeWithInjectorNotifier | PrivateInstance\r\n): ReplaySubject<boolean> {\r\n  if (target[InjectorNotifier]) {\r\n    return target[InjectorNotifier]!;\r\n  } else {\r\n    const injectorNotifier$ = new ReplaySubject<boolean>(1);\r\n    Object.defineProperty(target, InjectorNotifier, {\r\n      get: () => injectorNotifier$\r\n    });\r\n    return injectorNotifier$;\r\n  }\r\n}\r\n\r\n// eslint-disable-next-line @typescript-eslint/ban-types\r\nexport function ensureLocalInjectorCaptured(target: Object): void {\r\n  if (FactoryHasBeenDecorated in target.constructor.prototype) {\r\n    return;\r\n  }\r\n\r\n  const constructor: ConstructorWithDefinitionAndFactory = target.constructor;\r\n  // Means we're in AOT mode.\r\n  if (typeof constructor[NG_FACTORY_DEF] === 'function') {\r\n    decorateFactory(constructor);\r\n  } else if (ngDevMode) {\r\n    // We're running in JIT mode and that means we're not able to get the compiled definition\r\n    // on the class inside the property decorator during the current message loop tick. We have\r\n    // to wait for the next message loop tick. Note that this is safe since this Promise will be\r\n    // resolved even before the `APP_INITIALIZER` is resolved.\r\n    // The below code also will be executed only in development mode, since it's never recommended\r\n    // to use the JIT compiler in production mode (by setting \"aot: false\").\r\n    decorateFactoryLater(constructor);\r\n  }\r\n\r\n  target.constructor.prototype[FactoryHasBeenDecorated] = true;\r\n}\r\n\r\nexport function localInject<T>(\r\n  instance: PrivateInstance,\r\n  token: InjectionToken<T> | Type<T>\r\n): T | null {\r\n  const injector: Injector | undefined = instance[InjectorInstance];\r\n  return injector ? injector.get(token) : null;\r\n}\r\n\r\nfunction decorateFactory(constructor: ConstructorWithDefinitionAndFactory): void {\r\n  const factory = constructor[NG_FACTORY_DEF];\r\n\r\n  if (typeof factory !== 'function') {\r\n    return;\r\n  }\r\n\r\n  // Let's try to get any definition.\r\n  // Caretaker note: this will be compatible only with Angular 9+, since Angular 9 is the first\r\n  // Ivy-stable version. Previously definition properties were named differently (e.g. `ngComponentDef`).\r\n  const def = constructor.Éµprov || constructor.Éµpipe || constructor.Éµcmp || constructor.Éµdir;\r\n\r\n  const decoratedFactory = () => {\r\n    const instance = factory();\r\n    // Caretaker note: `inject()` won't work here.\r\n    // We can use the `directiveInject` only during the component\r\n    // construction, since Angular captures the currently active injector.\r\n    // We're not able to use this function inside the getter (when the `selectorId` property is\r\n    // requested for the first time), since the currently active injector will be null.\r\n    instance[InjectorInstance] = ÉµÉµdirectiveInject(\r\n      // We're using `INJECTOR` token except of the `Injector` class since the compiler\r\n      // throws: `Cannot assign an abstract constructor type to a non-abstract constructor type.`.\r\n      // Caretaker note: that this is the same way of getting the injector.\r\n      INJECTOR\r\n    );\r\n\r\n    // Caretaker note: the notifier will be available only if consumers call the `ensureInjectorNotifierIsCaptured()`.\r\n    const injectorNotifier$ = instance[InjectorNotifier];\r\n    if (injectorNotifier$) {\r\n      injectorNotifier$.next(true);\r\n      injectorNotifier$.complete();\r\n    }\r\n\r\n    return instance;\r\n  };\r\n\r\n  // If we've found any definition then it's enough to override the `def.factory` since Angular\r\n  // code uses the `def.factory` and then fallbacks to `Éµfac`.\r\n  if (def) {\r\n    def.factory = decoratedFactory;\r\n  }\r\n\r\n  // `@NgModule()` doesn't doesn't have definition factory, also providers have definitions but Angular\r\n  // still uses the `Éµfac`.\r\n  Object.defineProperty(constructor, NG_FACTORY_DEF, {\r\n    get: () => decoratedFactory\r\n  });\r\n}\r\n\r\nfunction decorateFactoryLater(constructor: ConstructorWithDefinitionAndFactory): void {\r\n  // This function actually will be tree-shaken away when building for production since it's guarded with `ngDevMode`.\r\n  // We're having the `try-catch` here because of the `SyncTestZoneSpec`, which throws\r\n  // an error when micro or macrotask is used within a synchronous test. E.g. `Cannot call\r\n  // Promise.then from within a sync test`.\r\n  try {\r\n    Promise.resolve().then(() => {\r\n      decorateFactory(constructor);\r\n    });\r\n  } catch {\r\n    // This is kind of a \"hack\", but we try to be backwards-compatible,\r\n    // tho this `catch` block will only be executed when tests are run with Jasmine or Jest.\r\n    Éµglobal.process &&\r\n      Éµglobal.process.nextTick &&\r\n      Éµglobal.process.nextTick(() => {\r\n        decorateFactory(constructor);\r\n      });\r\n  }\r\n}\r\n\r\n// We could've used `ÉµÉµFactoryDef` but we try to be backwards-compatible,\r\n// since it's not exported in older Angular versions.\r\ntype Factory = () => PrivateInstance;\r\n\r\n// We could've used `ÉµÉµInjectableDef`, `ÉµÉµPipeDef`, etc. We try to be backwards-compatible\r\n// since they're not exported in older Angular versions.\r\ninterface Definition {\r\n  factory: Factory | null;\r\n}\r\n\r\ninterface ConstructorWithDefinitionAndFactory extends Function {\r\n  // Provider definition for the `@Injectable()` class.\r\n  Éµprov?: Definition;\r\n  // Pipe definition for the `@Pipe()` class.\r\n  Éµpipe?: Definition;\r\n  // Component definition for the `@Component()` class.\r\n  Éµcmp?: Definition;\r\n  // Directive definition for the `@Directive()` class.\r\n  Éµdir?: Definition;\r\n  [NG_FACTORY_DEF]?: Factory;\r\n}\r\n\r\ninterface PrivateInstance {\r\n  [InjectorInstance]?: Injector;\r\n  [InjectorNotifier]?: ReplaySubject<boolean>;\r\n}\r\n"]}