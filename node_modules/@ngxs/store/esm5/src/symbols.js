/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Injectable, InjectionToken } from '@angular/core';
import { DispatchOutsideZoneNgxsExecutionStrategy } from './execution/dispatch-outside-zone-ngxs-execution-strategy';
/** @type {?} */
export var ROOT_STATE_TOKEN = new InjectionToken('ROOT_STATE_TOKEN');
/** @type {?} */
export var FEATURE_STATE_TOKEN = new InjectionToken('FEATURE_STATE_TOKEN');
/** @type {?} */
export var NGXS_PLUGINS = new InjectionToken('NGXS_PLUGINS');
/** @type {?} */
export var META_KEY = 'NGXS_META';
/** @type {?} */
export var META_OPTIONS_KEY = 'NGXS_OPTIONS_META';
/** @type {?} */
export var SELECTOR_META_KEY = 'NGXS_SELECTOR_META';
/**
 * The NGXS config settings.
 */
var NgxsConfig = /** @class */ (function () {
    function NgxsConfig() {
        /**
         * Defining the default state before module initialization
         * This is convenient if we need to create a define our own set of states.
         * @deprecated will be removed after v4
         * (default: {})
         */
        this.defaultsState = {};
        /**
         * Defining shared selector options
         */
        this.selectorOptions = {
            injectContainerState: true,
            // TODO: default is true in v3, will change in v4
            suppressErrors: true // TODO: default is true in v3, will change in v4
        };
        this.compatibility = {
            strictContentSecurityPolicy: false
        };
        this.executionStrategy = DispatchOutsideZoneNgxsExecutionStrategy;
    }
    NgxsConfig.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    NgxsConfig.ctorParameters = function () { return []; };
    return NgxsConfig;
}());
export { NgxsConfig };
if (false) {
    /**
     * Run in development mode. This will add additional debugging features:
     * - Object.freeze on the state and actions to guarantee immutability
     * (default: false)
     *
     * @deprecated This property is no longer necessary when the Ivy compiler is used.
     * We'll determine the development mode through the `ngDevMode`. It's still essential with View Engine.
     * @type {?}
     */
    NgxsConfig.prototype.developmentMode;
    /** @type {?} */
    NgxsConfig.prototype.compatibility;
    /**
     * Determines the execution context to perform async operations inside. An implementation can be
     * provided to override the default behaviour where the async operations are run
     * outside Angular's zone but all observable behaviours of NGXS are run back inside Angular's zone.
     * These observable behaviours are from:
     *   `\@Select(...)`, `store.select(...)`, `actions.subscribe(...)` or `store.dispatch(...).subscribe(...)`
     * Every `zone.run` causes Angular to run change detection on the whole tree (`app.tick()`) so of your
     * application doesn't rely on zone.js running change detection then you can switch to the
     * `NoopNgxsExecutionStrategy` that doesn't interact with zones.
     * (default: null)
     * @type {?}
     */
    NgxsConfig.prototype.executionStrategy;
    /**
     * Defining the default state before module initialization
     * This is convenient if we need to create a define our own set of states.
     * @deprecated will be removed after v4
     * (default: {})
     * @type {?}
     */
    NgxsConfig.prototype.defaultsState;
    /**
     * Defining shared selector options
     * @type {?}
     */
    NgxsConfig.prototype.selectorOptions;
}
/**
 * State context provided to the actions in the state.
 * @record
 * @template T
 */
export function StateContext() { }
if (false) {
    /**
     * Get the current state.
     * @return {?}
     */
    StateContext.prototype.getState = function () { };
    /**
     * Reset the state to a new value.
     * @param {?} val
     * @return {?}
     */
    StateContext.prototype.setState = function (val) { };
    /**
     * Patch the existing state with the provided value.
     * @param {?} val
     * @return {?}
     */
    StateContext.prototype.patchState = function (val) { };
    /**
     * Dispatch a new action and return the dispatched observable.
     * @param {?} actions
     * @return {?}
     */
    StateContext.prototype.dispatch = function (actions) { };
}
/**
 * Plugin interface
 * @record
 */
export function NgxsPlugin() { }
if (false) {
    /**
     * Handle the state/action before its submitted to the state handlers.
     * @param {?} state
     * @param {?} action
     * @param {?} next
     * @return {?}
     */
    NgxsPlugin.prototype.handle = function (state, action, next) { };
}
/**
 * Options that can be provided to the store.
 * @record
 * @template T
 */
export function StoreOptions() { }
if (false) {
    /**
     * Name of the state. Required.
     * @type {?}
     */
    StoreOptions.prototype.name;
    /**
     * Default values for the state. If not provided, uses empty object.
     * @type {?|undefined}
     */
    StoreOptions.prototype.defaults;
    /**
     * Sub states for the given state.
     * @type {?|undefined}
     */
    StoreOptions.prototype.children;
}
/**
 * Represents a basic change from a previous to a new value for a single state instance.
 * Passed as a value in a NgxsSimpleChanges object to the ngxsOnChanges hook.
 * @template T
 */
var /**
 * Represents a basic change from a previous to a new value for a single state instance.
 * Passed as a value in a NgxsSimpleChanges object to the ngxsOnChanges hook.
 * @template T
 */
NgxsSimpleChange = /** @class */ (function () {
    function NgxsSimpleChange(previousValue, currentValue, firstChange) {
        this.previousValue = previousValue;
        this.currentValue = currentValue;
        this.firstChange = firstChange;
    }
    return NgxsSimpleChange;
}());
/**
 * Represents a basic change from a previous to a new value for a single state instance.
 * Passed as a value in a NgxsSimpleChanges object to the ngxsOnChanges hook.
 * @template T
 */
export { NgxsSimpleChange };
if (false) {
    /** @type {?} */
    NgxsSimpleChange.prototype.previousValue;
    /** @type {?} */
    NgxsSimpleChange.prototype.currentValue;
    /** @type {?} */
    NgxsSimpleChange.prototype.firstChange;
}
/**
 * On init interface
 * @record
 */
export function NgxsOnInit() { }
if (false) {
    /**
     * @param {?=} ctx
     * @return {?}
     */
    NgxsOnInit.prototype.ngxsOnInit = function (ctx) { };
}
/**
 * On change interface
 * @record
 */
export function NgxsOnChanges() { }
if (false) {
    /**
     * @param {?} change
     * @return {?}
     */
    NgxsOnChanges.prototype.ngxsOnChanges = function (change) { };
}
/**
 * After bootstrap interface
 * @record
 */
export function NgxsAfterBootstrap() { }
if (false) {
    /**
     * @param {?=} ctx
     * @return {?}
     */
    NgxsAfterBootstrap.prototype.ngxsAfterBootstrap = function (ctx) { };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3ltYm9scy5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BuZ3hzL3N0b3JlLyIsInNvdXJjZXMiOlsic3JjL3N5bWJvbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsY0FBYyxFQUFRLE1BQU0sZUFBZSxDQUFDO0FBTWpFLE9BQU8sRUFBRSx3Q0FBd0MsRUFBRSxNQUFNLDJEQUEyRCxDQUFDOztBQUdySCxNQUFNLEtBQU8sZ0JBQWdCLEdBQUcsSUFBSSxjQUFjLENBQU0sa0JBQWtCLENBQUM7O0FBQzNFLE1BQU0sS0FBTyxtQkFBbUIsR0FBRyxJQUFJLGNBQWMsQ0FBTSxxQkFBcUIsQ0FBQzs7QUFDakYsTUFBTSxLQUFPLFlBQVksR0FBRyxJQUFJLGNBQWMsQ0FBQyxjQUFjLENBQUM7O0FBRTlELE1BQU0sS0FBTyxRQUFRLEdBQUcsV0FBVzs7QUFDbkMsTUFBTSxLQUFPLGdCQUFnQixHQUFHLG1CQUFtQjs7QUFDbkQsTUFBTSxLQUFPLGlCQUFpQixHQUFHLG9CQUFvQjs7OztBQVdyRDtJQThDRTs7Ozs7OztRQVRBLGtCQUFhLEdBQWdCLEVBQUUsQ0FBQzs7OztRQUloQyxvQkFBZSxHQUEwQjtZQUN2QyxvQkFBb0IsRUFBRSxJQUFJOztZQUMxQixjQUFjLEVBQUUsSUFBSSxDQUFDLGlEQUFpRDtTQUN2RSxDQUFDO1FBR0EsSUFBSSxDQUFDLGFBQWEsR0FBRztZQUNuQiwyQkFBMkIsRUFBRSxLQUFLO1NBQ25DLENBQUM7UUFDRixJQUFJLENBQUMsaUJBQWlCLEdBQUcsd0NBQXdDLENBQUM7SUFDcEUsQ0FBQzs7Z0JBbkRGLFVBQVU7Ozs7SUFvRFgsaUJBQUM7Q0FBQSxBQXBERCxJQW9EQztTQW5EWSxVQUFVOzs7Ozs7Ozs7OztJQVNyQixxQ0FBeUI7O0lBQ3pCLG1DQU9FOzs7Ozs7Ozs7Ozs7O0lBWUYsdUNBQStDOzs7Ozs7OztJQU8vQyxtQ0FBZ0M7Ozs7O0lBSWhDLHFDQUdFOzs7Ozs7O0FBZUosa0NBb0JDOzs7Ozs7SUFoQkMsa0RBQWM7Ozs7OztJQUtkLHFEQUF1Qzs7Ozs7O0lBS3ZDLHVEQUErQjs7Ozs7O0lBSy9CLHlEQUFpRDs7Ozs7O0FBUW5ELGdDQUtDOzs7Ozs7Ozs7SUFEQyxpRUFBNkQ7Ozs7Ozs7QUFNL0Qsa0NBZUM7Ozs7OztJQVhDLDRCQUE2Qjs7Ozs7SUFLN0IsZ0NBQWE7Ozs7O0lBS2IsZ0NBQXdCOzs7Ozs7O0FBTzFCOzs7Ozs7SUFDRSwwQkFDa0IsYUFBZ0IsRUFDaEIsWUFBZSxFQUNmLFdBQW9CO1FBRnBCLGtCQUFhLEdBQWIsYUFBYSxDQUFHO1FBQ2hCLGlCQUFZLEdBQVosWUFBWSxDQUFHO1FBQ2YsZ0JBQVcsR0FBWCxXQUFXLENBQVM7SUFDbkMsQ0FBQztJQUNOLHVCQUFDO0FBQUQsQ0FBQyxBQU5ELElBTUM7Ozs7Ozs7OztJQUpHLHlDQUFnQzs7SUFDaEMsd0NBQStCOztJQUMvQix1Q0FBb0M7Ozs7OztBQU94QyxnQ0FFQzs7Ozs7O0lBREMscURBQWdEOzs7Ozs7QUFNbEQsbUNBRUM7Ozs7OztJQURDLDhEQUE4Qzs7Ozs7O0FBTWhELHdDQUVDOzs7Ozs7SUFEQyxxRUFBa0QiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlLCBJbmplY3Rpb25Ub2tlbiwgVHlwZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XHJcblxyXG5pbXBvcnQgeyBQbGFpbk9iamVjdCwgU3RhdGVDbGFzcyB9IGZyb20gJ0BuZ3hzL3N0b3JlL2ludGVybmFscyc7XHJcbmltcG9ydCB7IFNoYXJlZFNlbGVjdG9yT3B0aW9ucyB9IGZyb20gJy4vaW50ZXJuYWwvaW50ZXJuYWxzJztcclxuaW1wb3J0IHsgTmd4c0V4ZWN1dGlvblN0cmF0ZWd5IH0gZnJvbSAnLi9leGVjdXRpb24vc3ltYm9scyc7XHJcbmltcG9ydCB7IERpc3BhdGNoT3V0c2lkZVpvbmVOZ3hzRXhlY3V0aW9uU3RyYXRlZ3kgfSBmcm9tICcuL2V4ZWN1dGlvbi9kaXNwYXRjaC1vdXRzaWRlLXpvbmUtbmd4cy1leGVjdXRpb24tc3RyYXRlZ3knO1xyXG5pbXBvcnQgeyBTdGF0ZVRva2VuIH0gZnJvbSAnLi9zdGF0ZS10b2tlbi9zdGF0ZS10b2tlbic7XHJcblxyXG5leHBvcnQgY29uc3QgUk9PVF9TVEFURV9UT0tFTiA9IG5ldyBJbmplY3Rpb25Ub2tlbjxhbnk+KCdST09UX1NUQVRFX1RPS0VOJyk7XHJcbmV4cG9ydCBjb25zdCBGRUFUVVJFX1NUQVRFX1RPS0VOID0gbmV3IEluamVjdGlvblRva2VuPGFueT4oJ0ZFQVRVUkVfU1RBVEVfVE9LRU4nKTtcclxuZXhwb3J0IGNvbnN0IE5HWFNfUExVR0lOUyA9IG5ldyBJbmplY3Rpb25Ub2tlbignTkdYU19QTFVHSU5TJyk7XHJcblxyXG5leHBvcnQgY29uc3QgTUVUQV9LRVkgPSAnTkdYU19NRVRBJztcclxuZXhwb3J0IGNvbnN0IE1FVEFfT1BUSU9OU19LRVkgPSAnTkdYU19PUFRJT05TX01FVEEnO1xyXG5leHBvcnQgY29uc3QgU0VMRUNUT1JfTUVUQV9LRVkgPSAnTkdYU19TRUxFQ1RPUl9NRVRBJztcclxuXHJcbmV4cG9ydCB0eXBlIE5neHNMaWZlQ3ljbGUgPSBQYXJ0aWFsPE5neHNPbkNoYW5nZXM+ICZcclxuICBQYXJ0aWFsPE5neHNPbkluaXQ+ICZcclxuICBQYXJ0aWFsPE5neHNBZnRlckJvb3RzdHJhcD47XHJcblxyXG5leHBvcnQgdHlwZSBOZ3hzUGx1Z2luRm4gPSAoc3RhdGU6IGFueSwgbXV0YXRpb246IGFueSwgbmV4dDogTmd4c05leHRQbHVnaW5GbikgPT4gYW55O1xyXG5cclxuLyoqXHJcbiAqIFRoZSBOR1hTIGNvbmZpZyBzZXR0aW5ncy5cclxuICovXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGNsYXNzIE5neHNDb25maWcge1xyXG4gIC8qKlxyXG4gICAqIFJ1biBpbiBkZXZlbG9wbWVudCBtb2RlLiBUaGlzIHdpbGwgYWRkIGFkZGl0aW9uYWwgZGVidWdnaW5nIGZlYXR1cmVzOlxyXG4gICAqIC0gT2JqZWN0LmZyZWV6ZSBvbiB0aGUgc3RhdGUgYW5kIGFjdGlvbnMgdG8gZ3VhcmFudGVlIGltbXV0YWJpbGl0eVxyXG4gICAqIChkZWZhdWx0OiBmYWxzZSlcclxuICAgKlxyXG4gICAqIEBkZXByZWNhdGVkIFRoaXMgcHJvcGVydHkgaXMgbm8gbG9uZ2VyIG5lY2Vzc2FyeSB3aGVuIHRoZSBJdnkgY29tcGlsZXIgaXMgdXNlZC5cclxuICAgKiBXZSdsbCBkZXRlcm1pbmUgdGhlIGRldmVsb3BtZW50IG1vZGUgdGhyb3VnaCB0aGUgYG5nRGV2TW9kZWAuIEl0J3Mgc3RpbGwgZXNzZW50aWFsIHdpdGggVmlldyBFbmdpbmUuXHJcbiAgICovXHJcbiAgZGV2ZWxvcG1lbnRNb2RlOiBib29sZWFuO1xyXG4gIGNvbXBhdGliaWxpdHk6IHtcclxuICAgIC8qKlxyXG4gICAgICogU3VwcG9ydCBhIHN0cmljdCBDb250ZW50IFNlY3VyaXR5IFBvbGljeS5cclxuICAgICAqIFRoaXMgd2lsbCBjaXJjdW12ZW50IHNvbWUgb3B0aW1pc2F0aW9ucyB0aGF0IHZpb2xhdGUgYSBzdHJpY3QgQ1NQIHRocm91Z2ggdGhlIHVzZSBvZiBgbmV3IEZ1bmN0aW9uKC4uLilgLlxyXG4gICAgICogKGRlZmF1bHQ6IGZhbHNlKVxyXG4gICAgICovXHJcbiAgICBzdHJpY3RDb250ZW50U2VjdXJpdHlQb2xpY3k6IGJvb2xlYW47XHJcbiAgfTtcclxuICAvKipcclxuICAgKiBEZXRlcm1pbmVzIHRoZSBleGVjdXRpb24gY29udGV4dCB0byBwZXJmb3JtIGFzeW5jIG9wZXJhdGlvbnMgaW5zaWRlLiBBbiBpbXBsZW1lbnRhdGlvbiBjYW4gYmVcclxuICAgKiBwcm92aWRlZCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCBiZWhhdmlvdXIgd2hlcmUgdGhlIGFzeW5jIG9wZXJhdGlvbnMgYXJlIHJ1blxyXG4gICAqIG91dHNpZGUgQW5ndWxhcidzIHpvbmUgYnV0IGFsbCBvYnNlcnZhYmxlIGJlaGF2aW91cnMgb2YgTkdYUyBhcmUgcnVuIGJhY2sgaW5zaWRlIEFuZ3VsYXIncyB6b25lLlxyXG4gICAqIFRoZXNlIG9ic2VydmFibGUgYmVoYXZpb3VycyBhcmUgZnJvbTpcclxuICAgKiAgIGBAU2VsZWN0KC4uLilgLCBgc3RvcmUuc2VsZWN0KC4uLilgLCBgYWN0aW9ucy5zdWJzY3JpYmUoLi4uKWAgb3IgYHN0b3JlLmRpc3BhdGNoKC4uLikuc3Vic2NyaWJlKC4uLilgXHJcbiAgICogRXZlcnkgYHpvbmUucnVuYCBjYXVzZXMgQW5ndWxhciB0byBydW4gY2hhbmdlIGRldGVjdGlvbiBvbiB0aGUgd2hvbGUgdHJlZSAoYGFwcC50aWNrKClgKSBzbyBvZiB5b3VyXHJcbiAgICogYXBwbGljYXRpb24gZG9lc24ndCByZWx5IG9uIHpvbmUuanMgcnVubmluZyBjaGFuZ2UgZGV0ZWN0aW9uIHRoZW4geW91IGNhbiBzd2l0Y2ggdG8gdGhlXHJcbiAgICogYE5vb3BOZ3hzRXhlY3V0aW9uU3RyYXRlZ3lgIHRoYXQgZG9lc24ndCBpbnRlcmFjdCB3aXRoIHpvbmVzLlxyXG4gICAqIChkZWZhdWx0OiBudWxsKVxyXG4gICAqL1xyXG4gIGV4ZWN1dGlvblN0cmF0ZWd5OiBUeXBlPE5neHNFeGVjdXRpb25TdHJhdGVneT47XHJcbiAgLyoqXHJcbiAgICogRGVmaW5pbmcgdGhlIGRlZmF1bHQgc3RhdGUgYmVmb3JlIG1vZHVsZSBpbml0aWFsaXphdGlvblxyXG4gICAqIFRoaXMgaXMgY29udmVuaWVudCBpZiB3ZSBuZWVkIHRvIGNyZWF0ZSBhIGRlZmluZSBvdXIgb3duIHNldCBvZiBzdGF0ZXMuXHJcbiAgICogQGRlcHJlY2F0ZWQgd2lsbCBiZSByZW1vdmVkIGFmdGVyIHY0XHJcbiAgICogKGRlZmF1bHQ6IHt9KVxyXG4gICAqL1xyXG4gIGRlZmF1bHRzU3RhdGU6IFBsYWluT2JqZWN0ID0ge307XHJcbiAgLyoqXHJcbiAgICogRGVmaW5pbmcgc2hhcmVkIHNlbGVjdG9yIG9wdGlvbnNcclxuICAgKi9cclxuICBzZWxlY3Rvck9wdGlvbnM6IFNoYXJlZFNlbGVjdG9yT3B0aW9ucyA9IHtcclxuICAgIGluamVjdENvbnRhaW5lclN0YXRlOiB0cnVlLCAvLyBUT0RPOiBkZWZhdWx0IGlzIHRydWUgaW4gdjMsIHdpbGwgY2hhbmdlIGluIHY0XHJcbiAgICBzdXBwcmVzc0Vycm9yczogdHJ1ZSAvLyBUT0RPOiBkZWZhdWx0IGlzIHRydWUgaW4gdjMsIHdpbGwgY2hhbmdlIGluIHY0XHJcbiAgfTtcclxuXHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICB0aGlzLmNvbXBhdGliaWxpdHkgPSB7XHJcbiAgICAgIHN0cmljdENvbnRlbnRTZWN1cml0eVBvbGljeTogZmFsc2VcclxuICAgIH07XHJcbiAgICB0aGlzLmV4ZWN1dGlvblN0cmF0ZWd5ID0gRGlzcGF0Y2hPdXRzaWRlWm9uZU5neHNFeGVjdXRpb25TdHJhdGVneTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIFN0YXRlT3BlcmF0b3I8VD4gPSAoZXhpc3Rpbmc6IFJlYWRvbmx5PFQ+KSA9PiBUO1xyXG5cclxuLyoqXHJcbiAqIFN0YXRlIGNvbnRleHQgcHJvdmlkZWQgdG8gdGhlIGFjdGlvbnMgaW4gdGhlIHN0YXRlLlxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBTdGF0ZUNvbnRleHQ8VD4ge1xyXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgY3VycmVudCBzdGF0ZS5cclxuICAgKi9cclxuICBnZXRTdGF0ZSgpOiBUO1xyXG5cclxuICAvKipcclxuICAgKiBSZXNldCB0aGUgc3RhdGUgdG8gYSBuZXcgdmFsdWUuXHJcbiAgICovXHJcbiAgc2V0U3RhdGUodmFsOiBUIHwgU3RhdGVPcGVyYXRvcjxUPik6IFQ7XHJcblxyXG4gIC8qKlxyXG4gICAqIFBhdGNoIHRoZSBleGlzdGluZyBzdGF0ZSB3aXRoIHRoZSBwcm92aWRlZCB2YWx1ZS5cclxuICAgKi9cclxuICBwYXRjaFN0YXRlKHZhbDogUGFydGlhbDxUPik6IFQ7XHJcblxyXG4gIC8qKlxyXG4gICAqIERpc3BhdGNoIGEgbmV3IGFjdGlvbiBhbmQgcmV0dXJuIHRoZSBkaXNwYXRjaGVkIG9ic2VydmFibGUuXHJcbiAgICovXHJcbiAgZGlzcGF0Y2goYWN0aW9uczogYW55IHwgYW55W10pOiBPYnNlcnZhYmxlPHZvaWQ+O1xyXG59XHJcblxyXG5leHBvcnQgdHlwZSBOZ3hzTmV4dFBsdWdpbkZuID0gKHN0YXRlOiBhbnksIG11dGF0aW9uOiBhbnkpID0+IGFueTtcclxuXHJcbi8qKlxyXG4gKiBQbHVnaW4gaW50ZXJmYWNlXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIE5neHNQbHVnaW4ge1xyXG4gIC8qKlxyXG4gICAqIEhhbmRsZSB0aGUgc3RhdGUvYWN0aW9uIGJlZm9yZSBpdHMgc3VibWl0dGVkIHRvIHRoZSBzdGF0ZSBoYW5kbGVycy5cclxuICAgKi9cclxuICBoYW5kbGUoc3RhdGU6IGFueSwgYWN0aW9uOiBhbnksIG5leHQ6IE5neHNOZXh0UGx1Z2luRm4pOiBhbnk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBPcHRpb25zIHRoYXQgY2FuIGJlIHByb3ZpZGVkIHRvIHRoZSBzdG9yZS5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgU3RvcmVPcHRpb25zPFQ+IHtcclxuICAvKipcclxuICAgKiBOYW1lIG9mIHRoZSBzdGF0ZS4gUmVxdWlyZWQuXHJcbiAgICovXHJcbiAgbmFtZTogc3RyaW5nIHwgU3RhdGVUb2tlbjxUPjtcclxuXHJcbiAgLyoqXHJcbiAgICogRGVmYXVsdCB2YWx1ZXMgZm9yIHRoZSBzdGF0ZS4gSWYgbm90IHByb3ZpZGVkLCB1c2VzIGVtcHR5IG9iamVjdC5cclxuICAgKi9cclxuICBkZWZhdWx0cz86IFQ7XHJcblxyXG4gIC8qKlxyXG4gICAqIFN1YiBzdGF0ZXMgZm9yIHRoZSBnaXZlbiBzdGF0ZS5cclxuICAgKi9cclxuICBjaGlsZHJlbj86IFN0YXRlQ2xhc3NbXTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYSBiYXNpYyBjaGFuZ2UgZnJvbSBhIHByZXZpb3VzIHRvIGEgbmV3IHZhbHVlIGZvciBhIHNpbmdsZSBzdGF0ZSBpbnN0YW5jZS5cclxuICogUGFzc2VkIGFzIGEgdmFsdWUgaW4gYSBOZ3hzU2ltcGxlQ2hhbmdlcyBvYmplY3QgdG8gdGhlIG5neHNPbkNoYW5nZXMgaG9vay5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBOZ3hzU2ltcGxlQ2hhbmdlPFQgPSBhbnk+IHtcclxuICBjb25zdHJ1Y3RvcihcclxuICAgIHB1YmxpYyByZWFkb25seSBwcmV2aW91c1ZhbHVlOiBULFxyXG4gICAgcHVibGljIHJlYWRvbmx5IGN1cnJlbnRWYWx1ZTogVCxcclxuICAgIHB1YmxpYyByZWFkb25seSBmaXJzdENoYW5nZTogYm9vbGVhblxyXG4gICkge31cclxufVxyXG5cclxuLyoqXHJcbiAqIE9uIGluaXQgaW50ZXJmYWNlXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIE5neHNPbkluaXQge1xyXG4gIG5neHNPbkluaXQoY3R4PzogU3RhdGVDb250ZXh0PGFueT4pOiB2b2lkIHwgYW55O1xyXG59XHJcblxyXG4vKipcclxuICogT24gY2hhbmdlIGludGVyZmFjZVxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBOZ3hzT25DaGFuZ2VzIHtcclxuICBuZ3hzT25DaGFuZ2VzKGNoYW5nZTogTmd4c1NpbXBsZUNoYW5nZSk6IHZvaWQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBZnRlciBib290c3RyYXAgaW50ZXJmYWNlXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIE5neHNBZnRlckJvb3RzdHJhcCB7XHJcbiAgbmd4c0FmdGVyQm9vdHN0cmFwKGN0eD86IFN0YXRlQ29udGV4dDxhbnk+KTogdm9pZDtcclxufVxyXG5cclxuZXhwb3J0IHR5cGUgTmd4c01vZHVsZU9wdGlvbnMgPSBQYXJ0aWFsPE5neHNDb25maWc+O1xyXG5cclxuLyoqIEBpbnRlcm5hbCAqL1xyXG5kZWNsYXJlIGdsb2JhbCB7XHJcbiAgY29uc3QgbmdEZXZNb2RlOiBib29sZWFuO1xyXG59XHJcbiJdfQ==