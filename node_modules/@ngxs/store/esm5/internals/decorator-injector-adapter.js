/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { INJECTOR, ɵɵdirectiveInject, ɵglobal } from '@angular/core';
import { ReplaySubject } from 'rxjs';
// Angular doesn't export `NG_FACTORY_DEF`.
/** @type {?} */
var NG_FACTORY_DEF = 'ɵfac';
// A `Symbol` which is used to save the `Injector` onto the class instance.
/** @type {?} */
var InjectorInstance = Symbol('InjectorInstance');
// A `Symbol` which is used to determine if factory has been decorated previously or not.
/** @type {?} */
var FactoryHasBeenDecorated = Symbol('FactoryHasBeenDecorated');
// A `Symbol` which is used to save the notifier on the class instance. The `InjectorInstance` cannot
// be retrieved within the `constructor` since it's set after the `factory()` is called.
/** @type {?} */
var InjectorNotifier = Symbol('InjectorNotifier');
/**
 * @record
 */
function PrototypeWithInjectorNotifier() { }
if (false) {
    /* Skipping unnamed member:
    [InjectorNotifier]?: ReplaySubject<boolean>;*/
}
/**
 * @param {?} target
 * @return {?}
 */
export function ensureInjectorNotifierIsCaptured(target) {
    if (target[InjectorNotifier]) {
        return (/** @type {?} */ (target[InjectorNotifier]));
    }
    else {
        /** @type {?} */
        var injectorNotifier$_1 = new ReplaySubject(1);
        Object.defineProperty(target, InjectorNotifier, {
            get: (/**
             * @return {?}
             */
            function () { return injectorNotifier$_1; })
        });
        return injectorNotifier$_1;
    }
}
// eslint-disable-next-line @typescript-eslint/ban-types
/**
 * @param {?} target
 * @return {?}
 */
export function ensureLocalInjectorCaptured(target) {
    if (FactoryHasBeenDecorated in target.constructor.prototype) {
        return;
    }
    /** @type {?} */
    var constructor = target.constructor;
    // Means we're in AOT mode.
    if (typeof constructor[NG_FACTORY_DEF] === 'function') {
        decorateFactory(constructor);
    }
    else if (ngDevMode) {
        // We're running in JIT mode and that means we're not able to get the compiled definition
        // on the class inside the property decorator during the current message loop tick. We have
        // to wait for the next message loop tick. Note that this is safe since this Promise will be
        // resolved even before the `APP_INITIALIZER` is resolved.
        // The below code also will be executed only in development mode, since it's never recommended
        // to use the JIT compiler in production mode (by setting "aot: false").
        decorateFactoryLater(constructor);
    }
    target.constructor.prototype[FactoryHasBeenDecorated] = true;
}
/**
 * @template T
 * @param {?} instance
 * @param {?} token
 * @return {?}
 */
export function localInject(instance, token) {
    /** @type {?} */
    var injector = instance[InjectorInstance];
    return injector ? injector.get(token) : null;
}
/**
 * @param {?} constructor
 * @return {?}
 */
function decorateFactory(constructor) {
    /** @type {?} */
    var factory = constructor[NG_FACTORY_DEF];
    if (typeof factory !== 'function') {
        return;
    }
    // Let's try to get any definition.
    // Caretaker note: this will be compatible only with Angular 9+, since Angular 9 is the first
    // Ivy-stable version. Previously definition properties were named differently (e.g. `ngComponentDef`).
    /** @type {?} */
    var def = constructor.ɵprov || constructor.ɵpipe || constructor.ɵcmp || constructor.ɵdir;
    /** @type {?} */
    var decoratedFactory = (/**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var instance = factory();
        // Caretaker note: `inject()` won't work here.
        // We can use the `directiveInject` only during the component
        // construction, since Angular captures the currently active injector.
        // We're not able to use this function inside the getter (when the `selectorId` property is
        // requested for the first time), since the currently active injector will be null.
        instance[InjectorInstance] = ɵɵdirectiveInject(
        // We're using `INJECTOR` token except of the `Injector` class since the compiler
        // throws: `Cannot assign an abstract constructor type to a non-abstract constructor type.`.
        // Caretaker note: that this is the same way of getting the injector.
        INJECTOR);
        // Caretaker note: the notifier will be available only if consumers call the `ensureInjectorNotifierIsCaptured()`.
        /** @type {?} */
        var injectorNotifier$ = instance[InjectorNotifier];
        if (injectorNotifier$) {
            injectorNotifier$.next(true);
            injectorNotifier$.complete();
        }
        return instance;
    });
    // If we've found any definition then it's enough to override the `def.factory` since Angular
    // code uses the `def.factory` and then fallbacks to `ɵfac`.
    if (def) {
        def.factory = decoratedFactory;
    }
    // `@NgModule()` doesn't doesn't have definition factory, also providers have definitions but Angular
    // still uses the `ɵfac`.
    Object.defineProperty(constructor, NG_FACTORY_DEF, {
        get: (/**
         * @return {?}
         */
        function () { return decoratedFactory; })
    });
}
/**
 * @param {?} constructor
 * @return {?}
 */
function decorateFactoryLater(constructor) {
    // This function actually will be tree-shaken away when building for production since it's guarded with `ngDevMode`.
    // We're having the `try-catch` here because of the `SyncTestZoneSpec`, which throws
    // an error when micro or macrotask is used within a synchronous test. E.g. `Cannot call
    // Promise.then from within a sync test`.
    try {
        Promise.resolve().then((/**
         * @return {?}
         */
        function () {
            decorateFactory(constructor);
        }));
    }
    catch (_a) {
        // This is kind of a "hack", but we try to be backwards-compatible,
        // tho this `catch` block will only be executed when tests are run with Jasmine or Jest.
        ɵglobal.process &&
            ɵglobal.process.nextTick &&
            ɵglobal.process.nextTick((/**
             * @return {?}
             */
            function () {
                decorateFactory(constructor);
            }));
    }
}
/**
 * @record
 */
function Definition() { }
if (false) {
    /** @type {?} */
    Definition.prototype.factory;
}
/**
 * @record
 */
function ConstructorWithDefinitionAndFactory() { }
if (false) {
    /** @type {?|undefined} */
    ConstructorWithDefinitionAndFactory.prototype.ɵprov;
    /** @type {?|undefined} */
    ConstructorWithDefinitionAndFactory.prototype.ɵpipe;
    /** @type {?|undefined} */
    ConstructorWithDefinitionAndFactory.prototype.ɵcmp;
    /** @type {?|undefined} */
    ConstructorWithDefinitionAndFactory.prototype.ɵdir;
    /* Skipping unnamed member:
    [NG_FACTORY_DEF]?: Factory;*/
}
/**
 * @record
 */
function PrivateInstance() { }
if (false) {
    /* Skipping unnamed member:
    [InjectorInstance]?: Injector;*/
    /* Skipping unnamed member:
    [InjectorNotifier]?: ReplaySubject<boolean>;*/
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVjb3JhdG9yLWluamVjdG9yLWFkYXB0ZXIuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9Abmd4cy9zdG9yZS9pbnRlcm5hbHMvIiwic291cmNlcyI6WyJkZWNvcmF0b3ItaW5qZWN0b3ItYWRhcHRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUdMLFFBQVEsRUFFUixpQkFBaUIsRUFDakIsT0FBTyxFQUNSLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSxNQUFNLENBQUM7OztJQU8vQixjQUFjLEdBQUcsTUFBTTs7O0lBR3ZCLGdCQUFnQixHQUFrQixNQUFNLENBQUMsa0JBQWtCLENBQUM7OztJQUc1RCx1QkFBdUIsR0FBa0IsTUFBTSxDQUFDLHlCQUF5QixDQUFDOzs7O0lBSTFFLGdCQUFnQixHQUFrQixNQUFNLENBQUMsa0JBQWtCLENBQUM7Ozs7QUFFbEUsNENBRUM7Ozs7Ozs7OztBQUVELE1BQU0sVUFBVSxnQ0FBZ0MsQ0FDOUMsTUFBdUQ7SUFFdkQsSUFBSSxNQUFNLENBQUMsZ0JBQWdCLENBQUMsRUFBRTtRQUM1QixPQUFPLG1CQUFBLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxFQUFDLENBQUM7S0FDbEM7U0FBTTs7WUFDQyxtQkFBaUIsR0FBRyxJQUFJLGFBQWEsQ0FBVSxDQUFDLENBQUM7UUFDdkQsTUFBTSxDQUFDLGNBQWMsQ0FBQyxNQUFNLEVBQUUsZ0JBQWdCLEVBQUU7WUFDOUMsR0FBRzs7O1lBQUUsY0FBTSxPQUFBLG1CQUFpQixFQUFqQixDQUFpQixDQUFBO1NBQzdCLENBQUMsQ0FBQztRQUNILE9BQU8sbUJBQWlCLENBQUM7S0FDMUI7QUFDSCxDQUFDOzs7Ozs7QUFHRCxNQUFNLFVBQVUsMkJBQTJCLENBQUMsTUFBYztJQUN4RCxJQUFJLHVCQUF1QixJQUFJLE1BQU0sQ0FBQyxXQUFXLENBQUMsU0FBUyxFQUFFO1FBQzNELE9BQU87S0FDUjs7UUFFSyxXQUFXLEdBQXdDLE1B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OztJQUVuQixvREFBbUI7O0lBRW5CLG1EQUFrQjs7SUFFbEIsbURBQWtCOzs7Ozs7O0FBSXBCLDhCQUdDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcclxuICBJbmplY3Rpb25Ub2tlbixcclxuICBJbmplY3RvcixcclxuICBJTkpFQ1RPUixcclxuICBUeXBlLFxyXG4gIMm1ybVkaXJlY3RpdmVJbmplY3QsXHJcbiAgybVnbG9iYWxcclxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgUmVwbGF5U3ViamVjdCB9IGZyb20gJ3J4anMnO1xyXG5cclxuLy8gV2lsbCBiZSBwcm92aWRlZCB0aHJvdWdoIFRlcnNlciBnbG9iYWwgZGVmaW5pdGlvbnMgYnkgQW5ndWxhciBDTElcclxuLy8gZHVyaW5nIHRoZSBwcm9kdWN0aW9uIGJ1aWxkLiBUaGlzIGlzIGhvdyBBbmd1bGFyIGRvZXMgdHJlZS1zaGFraW5nIGludGVybmFsbHkuXHJcbmRlY2xhcmUgY29uc3QgbmdEZXZNb2RlOiBib29sZWFuO1xyXG5cclxuLy8gQW5ndWxhciBkb2Vzbid0IGV4cG9ydCBgTkdfRkFDVE9SWV9ERUZgLlxyXG5jb25zdCBOR19GQUNUT1JZX0RFRiA9ICfJtWZhYyc7XHJcblxyXG4vLyBBIGBTeW1ib2xgIHdoaWNoIGlzIHVzZWQgdG8gc2F2ZSB0aGUgYEluamVjdG9yYCBvbnRvIHRoZSBjbGFzcyBpbnN0YW5jZS5cclxuY29uc3QgSW5qZWN0b3JJbnN0YW5jZTogdW5pcXVlIHN5bWJvbCA9IFN5bWJvbCgnSW5qZWN0b3JJbnN0YW5jZScpO1xyXG5cclxuLy8gQSBgU3ltYm9sYCB3aGljaCBpcyB1c2VkIHRvIGRldGVybWluZSBpZiBmYWN0b3J5IGhhcyBiZWVuIGRlY29yYXRlZCBwcmV2aW91c2x5IG9yIG5vdC5cclxuY29uc3QgRmFjdG9yeUhhc0JlZW5EZWNvcmF0ZWQ6IHVuaXF1ZSBzeW1ib2wgPSBTeW1ib2woJ0ZhY3RvcnlIYXNCZWVuRGVjb3JhdGVkJyk7XHJcblxyXG4vLyBBIGBTeW1ib2xgIHdoaWNoIGlzIHVzZWQgdG8gc2F2ZSB0aGUgbm90aWZpZXIgb24gdGhlIGNsYXNzIGluc3RhbmNlLiBUaGUgYEluamVjdG9ySW5zdGFuY2VgIGNhbm5vdFxyXG4vLyBiZSByZXRyaWV2ZWQgd2l0aGluIHRoZSBgY29uc3RydWN0b3JgIHNpbmNlIGl0J3Mgc2V0IGFmdGVyIHRoZSBgZmFjdG9yeSgpYCBpcyBjYWxsZWQuXHJcbmNvbnN0IEluamVjdG9yTm90aWZpZXI6IHVuaXF1ZSBzeW1ib2wgPSBTeW1ib2woJ0luamVjdG9yTm90aWZpZXInKTtcclxuXHJcbmludGVyZmFjZSBQcm90b3R5cGVXaXRoSW5qZWN0b3JOb3RpZmllciBleHRlbmRzIE9iamVjdCB7XHJcbiAgW0luamVjdG9yTm90aWZpZXJdPzogUmVwbGF5U3ViamVjdDxib29sZWFuPjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGVuc3VyZUluamVjdG9yTm90aWZpZXJJc0NhcHR1cmVkKFxyXG4gIHRhcmdldDogUHJvdG90eXBlV2l0aEluamVjdG9yTm90aWZpZXIgfCBQcml2YXRlSW5zdGFuY2VcclxuKTogUmVwbGF5U3ViamVjdDxib29sZWFuPiB7XHJcbiAgaWYgKHRhcmdldFtJbmplY3Rvck5vdGlmaWVyXSkge1xyXG4gICAgcmV0dXJuIHRhcmdldFtJbmplY3Rvck5vdGlmaWVyXSE7XHJcbiAgfSBlbHNlIHtcclxuICAgIGNvbnN0IGluamVjdG9yTm90aWZpZXIkID0gbmV3IFJlcGxheVN1YmplY3Q8Ym9vbGVhbj4oMSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBJbmplY3Rvck5vdGlmaWVyLCB7XHJcbiAgICAgIGdldDogKCkgPT4gaW5qZWN0b3JOb3RpZmllciRcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGluamVjdG9yTm90aWZpZXIkO1xyXG4gIH1cclxufVxyXG5cclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHlwZXNcclxuZXhwb3J0IGZ1bmN0aW9uIGVuc3VyZUxvY2FsSW5qZWN0b3JDYXB0dXJlZCh0YXJnZXQ6IE9iamVjdCk6IHZvaWQge1xyXG4gIGlmIChGYWN0b3J5SGFzQmVlbkRlY29yYXRlZCBpbiB0YXJnZXQuY29uc3RydWN0b3IucHJvdG90eXBlKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICBjb25zdCBjb25zdHJ1Y3RvcjogQ29uc3RydWN0b3JXaXRoRGVmaW5pdGlvbkFuZEZhY3RvcnkgPSB0YXJnZXQuY29uc3RydWN0b3I7XHJcbiAgLy8gTWVhbnMgd2UncmUgaW4gQU9UIG1vZGUuXHJcbiAgaWYgKHR5cGVvZiBjb25zdHJ1Y3RvcltOR19GQUNUT1JZX0RFRl0gPT09ICdmdW5jdGlvbicpIHtcclxuICAgIGRlY29yYXRlRmFjdG9yeShjb25zdHJ1Y3Rvcik7XHJcbiAgfSBlbHNlIGlmIChuZ0Rldk1vZGUpIHtcclxuICAgIC8vIFdlJ3JlIHJ1bm5pbmcgaW4gSklUIG1vZGUgYW5kIHRoYXQgbWVhbnMgd2UncmUgbm90IGFibGUgdG8gZ2V0IHRoZSBjb21waWxlZCBkZWZpbml0aW9uXHJcbiAgICAvLyBvbiB0aGUgY2xhc3MgaW5zaWRlIHRoZSBwcm9wZXJ0eSBkZWNvcmF0b3IgZHVyaW5nIHRoZSBjdXJyZW50IG1lc3NhZ2UgbG9vcCB0aWNrLiBXZSBoYXZlXHJcbiAgICAvLyB0byB3YWl0IGZvciB0aGUgbmV4dCBtZXNzYWdlIGxvb3AgdGljay4gTm90ZSB0aGF0IHRoaXMgaXMgc2FmZSBzaW5jZSB0aGlzIFByb21pc2Ugd2lsbCBiZVxyXG4gICAgLy8gcmVzb2x2ZWQgZXZlbiBiZWZvcmUgdGhlIGBBUFBfSU5JVElBTElaRVJgIGlzIHJlc29sdmVkLlxyXG4gICAgLy8gVGhlIGJlbG93IGNvZGUgYWxzbyB3aWxsIGJlIGV4ZWN1dGVkIG9ubHkgaW4gZGV2ZWxvcG1lbnQgbW9kZSwgc2luY2UgaXQncyBuZXZlciByZWNvbW1lbmRlZFxyXG4gICAgLy8gdG8gdXNlIHRoZSBKSVQgY29tcGlsZXIgaW4gcHJvZHVjdGlvbiBtb2RlIChieSBzZXR0aW5nIFwiYW90OiBmYWxzZVwiKS5cclxuICAgIGRlY29yYXRlRmFjdG9yeUxhdGVyKGNvbnN0cnVjdG9yKTtcclxuICB9XHJcblxyXG4gIHRhcmdldC5jb25zdHJ1Y3Rvci5wcm90b3R5cGVbRmFjdG9yeUhhc0JlZW5EZWNvcmF0ZWRdID0gdHJ1ZTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGxvY2FsSW5qZWN0PFQ+KFxyXG4gIGluc3RhbmNlOiBQcml2YXRlSW5zdGFuY2UsXHJcbiAgdG9rZW46IEluamVjdGlvblRva2VuPFQ+IHwgVHlwZTxUPlxyXG4pOiBUIHwgbnVsbCB7XHJcbiAgY29uc3QgaW5qZWN0b3I6IEluamVjdG9yIHwgdW5kZWZpbmVkID0gaW5zdGFuY2VbSW5qZWN0b3JJbnN0YW5jZV07XHJcbiAgcmV0dXJuIGluamVjdG9yID8gaW5qZWN0b3IuZ2V0KHRva2VuKSA6IG51bGw7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRlY29yYXRlRmFjdG9yeShjb25zdHJ1Y3RvcjogQ29uc3RydWN0b3JXaXRoRGVmaW5pdGlvbkFuZEZhY3RvcnkpOiB2b2lkIHtcclxuICBjb25zdCBmYWN0b3J5ID0gY29uc3RydWN0b3JbTkdfRkFDVE9SWV9ERUZdO1xyXG5cclxuICBpZiAodHlwZW9mIGZhY3RvcnkgIT09ICdmdW5jdGlvbicpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIC8vIExldCdzIHRyeSB0byBnZXQgYW55IGRlZmluaXRpb24uXHJcbiAgLy8gQ2FyZXRha2VyIG5vdGU6IHRoaXMgd2lsbCBiZSBjb21wYXRpYmxlIG9ubHkgd2l0aCBBbmd1bGFyIDkrLCBzaW5jZSBBbmd1bGFyIDkgaXMgdGhlIGZpcnN0XHJcbiAgLy8gSXZ5LXN0YWJsZSB2ZXJzaW9uLiBQcmV2aW91c2x5IGRlZmluaXRpb24gcHJvcGVydGllcyB3ZXJlIG5hbWVkIGRpZmZlcmVudGx5IChlLmcuIGBuZ0NvbXBvbmVudERlZmApLlxyXG4gIGNvbnN0IGRlZiA9IGNvbnN0cnVjdG9yLsm1cHJvdiB8fCBjb25zdHJ1Y3Rvci7JtXBpcGUgfHwgY29uc3RydWN0b3IuybVjbXAgfHwgY29uc3RydWN0b3IuybVkaXI7XHJcblxyXG4gIGNvbnN0IGRlY29yYXRlZEZhY3RvcnkgPSAoKSA9PiB7XHJcbiAgICBjb25zdCBpbnN0YW5jZSA9IGZhY3RvcnkoKTtcclxuICAgIC8vIENhcmV0YWtlciBub3RlOiBgaW5qZWN0KClgIHdvbid0IHdvcmsgaGVyZS5cclxuICAgIC8vIFdlIGNhbiB1c2UgdGhlIGBkaXJlY3RpdmVJbmplY3RgIG9ubHkgZHVyaW5nIHRoZSBjb21wb25lbnRcclxuICAgIC8vIGNvbnN0cnVjdGlvbiwgc2luY2UgQW5ndWxhciBjYXB0dXJlcyB0aGUgY3VycmVudGx5IGFjdGl2ZSBpbmplY3Rvci5cclxuICAgIC8vIFdlJ3JlIG5vdCBhYmxlIHRvIHVzZSB0aGlzIGZ1bmN0aW9uIGluc2lkZSB0aGUgZ2V0dGVyICh3aGVuIHRoZSBgc2VsZWN0b3JJZGAgcHJvcGVydHkgaXNcclxuICAgIC8vIHJlcXVlc3RlZCBmb3IgdGhlIGZpcnN0IHRpbWUpLCBzaW5jZSB0aGUgY3VycmVudGx5IGFjdGl2ZSBpbmplY3RvciB3aWxsIGJlIG51bGwuXHJcbiAgICBpbnN0YW5jZVtJbmplY3Rvckluc3RhbmNlXSA9IMm1ybVkaXJlY3RpdmVJbmplY3QoXHJcbiAgICAgIC8vIFdlJ3JlIHVzaW5nIGBJTkpFQ1RPUmAgdG9rZW4gZXhjZXB0IG9mIHRoZSBgSW5qZWN0b3JgIGNsYXNzIHNpbmNlIHRoZSBjb21waWxlclxyXG4gICAgICAvLyB0aHJvd3M6IGBDYW5ub3QgYXNzaWduIGFuIGFic3RyYWN0IGNvbnN0cnVjdG9yIHR5cGUgdG8gYSBub24tYWJzdHJhY3QgY29uc3RydWN0b3IgdHlwZS5gLlxyXG4gICAgICAvLyBDYXJldGFrZXIgbm90ZTogdGhhdCB0aGlzIGlzIHRoZSBzYW1lIHdheSBvZiBnZXR0aW5nIHRoZSBpbmplY3Rvci5cclxuICAgICAgSU5KRUNUT1JcclxuICAgICk7XHJcblxyXG4gICAgLy8gQ2FyZXRha2VyIG5vdGU6IHRoZSBub3RpZmllciB3aWxsIGJlIGF2YWlsYWJsZSBvbmx5IGlmIGNvbnN1bWVycyBjYWxsIHRoZSBgZW5zdXJlSW5qZWN0b3JOb3RpZmllcklzQ2FwdHVyZWQoKWAuXHJcbiAgICBjb25zdCBpbmplY3Rvck5vdGlmaWVyJCA9IGluc3RhbmNlW0luamVjdG9yTm90aWZpZXJdO1xyXG4gICAgaWYgKGluamVjdG9yTm90aWZpZXIkKSB7XHJcbiAgICAgIGluamVjdG9yTm90aWZpZXIkLm5leHQodHJ1ZSk7XHJcbiAgICAgIGluamVjdG9yTm90aWZpZXIkLmNvbXBsZXRlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGluc3RhbmNlO1xyXG4gIH07XHJcblxyXG4gIC8vIElmIHdlJ3ZlIGZvdW5kIGFueSBkZWZpbml0aW9uIHRoZW4gaXQncyBlbm91Z2ggdG8gb3ZlcnJpZGUgdGhlIGBkZWYuZmFjdG9yeWAgc2luY2UgQW5ndWxhclxyXG4gIC8vIGNvZGUgdXNlcyB0aGUgYGRlZi5mYWN0b3J5YCBhbmQgdGhlbiBmYWxsYmFja3MgdG8gYMm1ZmFjYC5cclxuICBpZiAoZGVmKSB7XHJcbiAgICBkZWYuZmFjdG9yeSA9IGRlY29yYXRlZEZhY3Rvcnk7XHJcbiAgfVxyXG5cclxuICAvLyBgQE5nTW9kdWxlKClgIGRvZXNuJ3QgZG9lc24ndCBoYXZlIGRlZmluaXRpb24gZmFjdG9yeSwgYWxzbyBwcm92aWRlcnMgaGF2ZSBkZWZpbml0aW9ucyBidXQgQW5ndWxhclxyXG4gIC8vIHN0aWxsIHVzZXMgdGhlIGDJtWZhY2AuXHJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvbnN0cnVjdG9yLCBOR19GQUNUT1JZX0RFRiwge1xyXG4gICAgZ2V0OiAoKSA9PiBkZWNvcmF0ZWRGYWN0b3J5XHJcbiAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRlY29yYXRlRmFjdG9yeUxhdGVyKGNvbnN0cnVjdG9yOiBDb25zdHJ1Y3RvcldpdGhEZWZpbml0aW9uQW5kRmFjdG9yeSk6IHZvaWQge1xyXG4gIC8vIFRoaXMgZnVuY3Rpb24gYWN0dWFsbHkgd2lsbCBiZSB0cmVlLXNoYWtlbiBhd2F5IHdoZW4gYnVpbGRpbmcgZm9yIHByb2R1Y3Rpb24gc2luY2UgaXQncyBndWFyZGVkIHdpdGggYG5nRGV2TW9kZWAuXHJcbiAgLy8gV2UncmUgaGF2aW5nIHRoZSBgdHJ5LWNhdGNoYCBoZXJlIGJlY2F1c2Ugb2YgdGhlIGBTeW5jVGVzdFpvbmVTcGVjYCwgd2hpY2ggdGhyb3dzXHJcbiAgLy8gYW4gZXJyb3Igd2hlbiBtaWNybyBvciBtYWNyb3Rhc2sgaXMgdXNlZCB3aXRoaW4gYSBzeW5jaHJvbm91cyB0ZXN0LiBFLmcuIGBDYW5ub3QgY2FsbFxyXG4gIC8vIFByb21pc2UudGhlbiBmcm9tIHdpdGhpbiBhIHN5bmMgdGVzdGAuXHJcbiAgdHJ5IHtcclxuICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xyXG4gICAgICBkZWNvcmF0ZUZhY3RvcnkoY29uc3RydWN0b3IpO1xyXG4gICAgfSk7XHJcbiAgfSBjYXRjaCB7XHJcbiAgICAvLyBUaGlzIGlzIGtpbmQgb2YgYSBcImhhY2tcIiwgYnV0IHdlIHRyeSB0byBiZSBiYWNrd2FyZHMtY29tcGF0aWJsZSxcclxuICAgIC8vIHRobyB0aGlzIGBjYXRjaGAgYmxvY2sgd2lsbCBvbmx5IGJlIGV4ZWN1dGVkIHdoZW4gdGVzdHMgYXJlIHJ1biB3aXRoIEphc21pbmUgb3IgSmVzdC5cclxuICAgIMm1Z2xvYmFsLnByb2Nlc3MgJiZcclxuICAgICAgybVnbG9iYWwucHJvY2Vzcy5uZXh0VGljayAmJlxyXG4gICAgICDJtWdsb2JhbC5wcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcclxuICAgICAgICBkZWNvcmF0ZUZhY3RvcnkoY29uc3RydWN0b3IpO1xyXG4gICAgICB9KTtcclxuICB9XHJcbn1cclxuXHJcbi8vIFdlIGNvdWxkJ3ZlIHVzZWQgYMm1ybVGYWN0b3J5RGVmYCBidXQgd2UgdHJ5IHRvIGJlIGJhY2t3YXJkcy1jb21wYXRpYmxlLFxyXG4vLyBzaW5jZSBpdCdzIG5vdCBleHBvcnRlZCBpbiBvbGRlciBBbmd1bGFyIHZlcnNpb25zLlxyXG50eXBlIEZhY3RvcnkgPSAoKSA9PiBQcml2YXRlSW5zdGFuY2U7XHJcblxyXG4vLyBXZSBjb3VsZCd2ZSB1c2VkIGDJtcm1SW5qZWN0YWJsZURlZmAsIGDJtcm1UGlwZURlZmAsIGV0Yy4gV2UgdHJ5IHRvIGJlIGJhY2t3YXJkcy1jb21wYXRpYmxlXHJcbi8vIHNpbmNlIHRoZXkncmUgbm90IGV4cG9ydGVkIGluIG9sZGVyIEFuZ3VsYXIgdmVyc2lvbnMuXHJcbmludGVyZmFjZSBEZWZpbml0aW9uIHtcclxuICBmYWN0b3J5OiBGYWN0b3J5IHwgbnVsbDtcclxufVxyXG5cclxuaW50ZXJmYWNlIENvbnN0cnVjdG9yV2l0aERlZmluaXRpb25BbmRGYWN0b3J5IGV4dGVuZHMgRnVuY3Rpb24ge1xyXG4gIC8vIFByb3ZpZGVyIGRlZmluaXRpb24gZm9yIHRoZSBgQEluamVjdGFibGUoKWAgY2xhc3MuXHJcbiAgybVwcm92PzogRGVmaW5pdGlvbjtcclxuICAvLyBQaXBlIGRlZmluaXRpb24gZm9yIHRoZSBgQFBpcGUoKWAgY2xhc3MuXHJcbiAgybVwaXBlPzogRGVmaW5pdGlvbjtcclxuICAvLyBDb21wb25lbnQgZGVmaW5pdGlvbiBmb3IgdGhlIGBAQ29tcG9uZW50KClgIGNsYXNzLlxyXG4gIMm1Y21wPzogRGVmaW5pdGlvbjtcclxuICAvLyBEaXJlY3RpdmUgZGVmaW5pdGlvbiBmb3IgdGhlIGBARGlyZWN0aXZlKClgIGNsYXNzLlxyXG4gIMm1ZGlyPzogRGVmaW5pdGlvbjtcclxuICBbTkdfRkFDVE9SWV9ERUZdPzogRmFjdG9yeTtcclxufVxyXG5cclxuaW50ZXJmYWNlIFByaXZhdGVJbnN0YW5jZSB7XHJcbiAgW0luamVjdG9ySW5zdGFuY2VdPzogSW5qZWN0b3I7XHJcbiAgW0luamVjdG9yTm90aWZpZXJdPzogUmVwbGF5U3ViamVjdDxib29sZWFuPjtcclxufVxyXG4iXX0=