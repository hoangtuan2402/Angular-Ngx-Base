/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { throwSelectorDecoratorError } from '../../configs/messages.config';
import { createSelector } from '../../utils/selector-utils';
/**
 * Decorator for memoizing a state selector.
 * @template T
 * @param {?=} selectors
 * @return {?}
 */
export function Selector(selectors) {
    return (/**
     * @template U
     * @param {?} target
     * @param {?} key
     * @param {?} descriptor
     * @return {?}
     */
    (target, key, descriptor) => {
        // Caretaker note: we have still left the `typeof` condition in order to avoid
        // creating a breaking change for projects that still use the View Engine.
        if (typeof ngDevMode === 'undefined' || ngDevMode) {
            /** @type {?} */
            const isNotMethod = !(descriptor && descriptor.value !== null);
            if (isNotMethod) {
                throwSelectorDecoratorError();
            }
        }
        /** @type {?} */
        const originalFn = descriptor.value;
        /** @type {?} */
        const memoizedFn = createSelector(selectors, (/** @type {?} */ (originalFn)), {
            containerClass: target,
            selectorName: key.toString(),
            /**
             * @return {?}
             */
            getSelectorOptions() {
                return {};
            }
        });
        /** @type {?} */
        const newDescriptor = {
            configurable: true,
            /**
             * @return {?}
             */
            get() {
                return memoizedFn;
            }
        };
        // Add hidden property to descriptor
        ((/** @type {?} */ (newDescriptor)))['originalFn'] = originalFn;
        return newDescriptor;
    });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VsZWN0b3IuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9Abmd4cy9zdG9yZS8iLCJzb3VyY2VzIjpbInNyYy9kZWNvcmF0b3JzL3NlbGVjdG9yL3NlbGVjdG9yLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPLEVBQUUsMkJBQTJCLEVBQUUsTUFBTSwrQkFBK0IsQ0FBQztBQUM1RSxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sNEJBQTRCLENBQUM7Ozs7Ozs7QUFNNUQsTUFBTSxVQUFVLFFBQVEsQ0FBSSxTQUFlO0lBQ3pDOzs7Ozs7O0lBQU8sQ0FDTCxNQUFXLEVBQ1gsR0FBb0IsRUFDcEIsVUFBdUQsRUFDSCxFQUFFO1FBQ3RELDhFQUE4RTtRQUM5RSwwRUFBMEU7UUFDMUUsSUFBSSxPQUFPLFNBQVMsS0FBSyxXQUFXLElBQUksU0FBUyxFQUFFOztrQkFDM0MsV0FBVyxHQUFHLENBQUMsQ0FBQyxVQUFVLElBQUksVUFBVSxDQUFDLEtBQUssS0FBSyxJQUFJLENBQUM7WUFFOUQsSUFBSSxXQUFXLEVBQUU7Z0JBQ2YsMkJBQTJCLEVBQUUsQ0FBQzthQUMvQjtTQUNGOztjQUVLLFVBQVUsR0FBRyxVQUFVLENBQUMsS0FBSzs7Y0FDN0IsVUFBVSxHQUFHLGNBQWMsQ0FBQyxTQUFTLEVBQUUsbUJBQUEsVUFBVSxFQUFPLEVBQUU7WUFDOUQsY0FBYyxFQUFFLE1BQU07WUFDdEIsWUFBWSxFQUFFLEdBQUcsQ0FBQyxRQUFRLEVBQUU7Ozs7WUFDNUIsa0JBQWtCO2dCQUNoQixPQUFPLEVBQUUsQ0FBQztZQUNaLENBQUM7U0FDRixDQUFDOztjQUNJLGFBQWEsR0FBRztZQUNwQixZQUFZLEVBQUUsSUFBSTs7OztZQUNsQixHQUFHO2dCQUNELE9BQU8sVUFBVSxDQUFDO1lBQ3BCLENBQUM7U0FDRjtRQUNELG9DQUFvQztRQUNwQyxDQUFDLG1CQUFLLGFBQWEsRUFBQSxDQUFDLENBQUMsWUFBWSxDQUFDLEdBQUcsVUFBVSxDQUFDO1FBQ2hELE9BQU8sYUFBYSxDQUFDO0lBQ3ZCLENBQUMsRUFBQztBQUNKLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB0aHJvd1NlbGVjdG9yRGVjb3JhdG9yRXJyb3IgfSBmcm9tICcuLi8uLi9jb25maWdzL21lc3NhZ2VzLmNvbmZpZyc7XHJcbmltcG9ydCB7IGNyZWF0ZVNlbGVjdG9yIH0gZnJvbSAnLi4vLi4vdXRpbHMvc2VsZWN0b3ItdXRpbHMnO1xyXG5pbXBvcnQgeyBTZWxlY3RvclNwZWMsIFNlbGVjdG9yVHlwZSB9IGZyb20gJy4vc3ltYm9scyc7XHJcblxyXG4vKipcclxuICogRGVjb3JhdG9yIGZvciBtZW1vaXppbmcgYSBzdGF0ZSBzZWxlY3Rvci5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBTZWxlY3RvcjxUPihzZWxlY3RvcnM/OiBUW10pOiBTZWxlY3RvclR5cGU8VD4ge1xyXG4gIHJldHVybiA8VT4oXHJcbiAgICB0YXJnZXQ6IGFueSxcclxuICAgIGtleTogc3RyaW5nIHwgc3ltYm9sLFxyXG4gICAgZGVzY3JpcHRvcjogVHlwZWRQcm9wZXJ0eURlc2NyaXB0b3I8U2VsZWN0b3JTcGVjPFQsIFU+PlxyXG4gICk6IFR5cGVkUHJvcGVydHlEZXNjcmlwdG9yPFNlbGVjdG9yU3BlYzxULCBVPj4gfCB2b2lkID0+IHtcclxuICAgIC8vIENhcmV0YWtlciBub3RlOiB3ZSBoYXZlIHN0aWxsIGxlZnQgdGhlIGB0eXBlb2ZgIGNvbmRpdGlvbiBpbiBvcmRlciB0byBhdm9pZFxyXG4gICAgLy8gY3JlYXRpbmcgYSBicmVha2luZyBjaGFuZ2UgZm9yIHByb2plY3RzIHRoYXQgc3RpbGwgdXNlIHRoZSBWaWV3IEVuZ2luZS5cclxuICAgIGlmICh0eXBlb2YgbmdEZXZNb2RlID09PSAndW5kZWZpbmVkJyB8fCBuZ0Rldk1vZGUpIHtcclxuICAgICAgY29uc3QgaXNOb3RNZXRob2QgPSAhKGRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci52YWx1ZSAhPT0gbnVsbCk7XHJcblxyXG4gICAgICBpZiAoaXNOb3RNZXRob2QpIHtcclxuICAgICAgICB0aHJvd1NlbGVjdG9yRGVjb3JhdG9yRXJyb3IoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IG9yaWdpbmFsRm4gPSBkZXNjcmlwdG9yLnZhbHVlO1xyXG4gICAgY29uc3QgbWVtb2l6ZWRGbiA9IGNyZWF0ZVNlbGVjdG9yKHNlbGVjdG9ycywgb3JpZ2luYWxGbiBhcyBhbnksIHtcclxuICAgICAgY29udGFpbmVyQ2xhc3M6IHRhcmdldCxcclxuICAgICAgc2VsZWN0b3JOYW1lOiBrZXkudG9TdHJpbmcoKSxcclxuICAgICAgZ2V0U2VsZWN0b3JPcHRpb25zKCkge1xyXG4gICAgICAgIHJldHVybiB7fTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBjb25zdCBuZXdEZXNjcmlwdG9yID0ge1xyXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgIGdldCgpIHtcclxuICAgICAgICByZXR1cm4gbWVtb2l6ZWRGbjtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIEFkZCBoaWRkZW4gcHJvcGVydHkgdG8gZGVzY3JpcHRvclxyXG4gICAgKDxhbnk+bmV3RGVzY3JpcHRvcilbJ29yaWdpbmFsRm4nXSA9IG9yaWdpbmFsRm47XHJcbiAgICByZXR1cm4gbmV3RGVzY3JpcHRvcjtcclxuICB9O1xyXG59XHJcbiJdfQ==