/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { INJECTOR, ɵɵdirectiveInject, ɵglobal } from '@angular/core';
import { ReplaySubject } from 'rxjs';
// Angular doesn't export `NG_FACTORY_DEF`.
/** @type {?} */
const NG_FACTORY_DEF = 'ɵfac';
// A `Symbol` which is used to save the `Injector` onto the class instance.
/** @type {?} */
const InjectorInstance = Symbol('InjectorInstance');
// A `Symbol` which is used to determine if factory has been decorated previously or not.
/** @type {?} */
const FactoryHasBeenDecorated = Symbol('FactoryHasBeenDecorated');
// A `Symbol` which is used to save the notifier on the class instance. The `InjectorInstance` cannot
// be retrieved within the `constructor` since it's set after the `factory()` is called.
/** @type {?} */
const InjectorNotifier = Symbol('InjectorNotifier');
/**
 * @record
 */
function PrototypeWithInjectorNotifier() { }
if (false) {
    /* Skipping unnamed member:
    [InjectorNotifier]?: ReplaySubject<boolean>;*/
}
/**
 * @param {?} target
 * @return {?}
 */
export function ensureInjectorNotifierIsCaptured(target) {
    if (target[InjectorNotifier]) {
        return (/** @type {?} */ (target[InjectorNotifier]));
    }
    else {
        /** @type {?} */
        const injectorNotifier$ = new ReplaySubject(1);
        Object.defineProperty(target, InjectorNotifier, {
            get: (/**
             * @return {?}
             */
            () => injectorNotifier$)
        });
        return injectorNotifier$;
    }
}
// eslint-disable-next-line @typescript-eslint/ban-types
/**
 * @param {?} target
 * @return {?}
 */
export function ensureLocalInjectorCaptured(target) {
    if (FactoryHasBeenDecorated in target.constructor.prototype) {
        return;
    }
    /** @type {?} */
    const constructor = target.constructor;
    // Means we're in AOT mode.
    if (typeof constructor[NG_FACTORY_DEF] === 'function') {
        decorateFactory(constructor);
    }
    else if (ngDevMode) {
        // We're running in JIT mode and that means we're not able to get the compiled definition
        // on the class inside the property decorator during the current message loop tick. We have
        // to wait for the next message loop tick. Note that this is safe since this Promise will be
        // resolved even before the `APP_INITIALIZER` is resolved.
        // The below code also will be executed only in development mode, since it's never recommended
        // to use the JIT compiler in production mode (by setting "aot: false").
        decorateFactoryLater(constructor);
    }
    target.constructor.prototype[FactoryHasBeenDecorated] = true;
}
/**
 * @template T
 * @param {?} instance
 * @param {?} token
 * @return {?}
 */
export function localInject(instance, token) {
    /** @type {?} */
    const injector = instance[InjectorInstance];
    return injector ? injector.get(token) : null;
}
/**
 * @param {?} constructor
 * @return {?}
 */
function decorateFactory(constructor) {
    /** @type {?} */
    const factory = constructor[NG_FACTORY_DEF];
    if (typeof factory !== 'function') {
        return;
    }
    // Let's try to get any definition.
    // Caretaker note: this will be compatible only with Angular 9+, since Angular 9 is the first
    // Ivy-stable version. Previously definition properties were named differently (e.g. `ngComponentDef`).
    /** @type {?} */
    const def = constructor.ɵprov || constructor.ɵpipe || constructor.ɵcmp || constructor.ɵdir;
    /** @type {?} */
    const decoratedFactory = (/**
     * @return {?}
     */
    () => {
        /** @type {?} */
        const instance = factory();
        // Caretaker note: `inject()` won't work here.
        // We can use the `directiveInject` only during the component
        // construction, since Angular captures the currently active injector.
        // We're not able to use this function inside the getter (when the `selectorId` property is
        // requested for the first time), since the currently active injector will be null.
        instance[InjectorInstance] = ɵɵdirectiveInject(
        // We're using `INJECTOR` token except of the `Injector` class since the compiler
        // throws: `Cannot assign an abstract constructor type to a non-abstract constructor type.`.
        // Caretaker note: that this is the same way of getting the injector.
        INJECTOR);
        // Caretaker note: the notifier will be available only if consumers call the `ensureInjectorNotifierIsCaptured()`.
        /** @type {?} */
        const injectorNotifier$ = instance[InjectorNotifier];
        if (injectorNotifier$) {
            injectorNotifier$.next(true);
            injectorNotifier$.complete();
        }
        return instance;
    });
    // If we've found any definition then it's enough to override the `def.factory` since Angular
    // code uses the `def.factory` and then fallbacks to `ɵfac`.
    if (def) {
        def.factory = decoratedFactory;
    }
    // `@NgModule()` doesn't doesn't have definition factory, also providers have definitions but Angular
    // still uses the `ɵfac`.
    Object.defineProperty(constructor, NG_FACTORY_DEF, {
        get: (/**
         * @return {?}
         */
        () => decoratedFactory)
    });
}
/**
 * @param {?} constructor
 * @return {?}
 */
function decorateFactoryLater(constructor) {
    // This function actually will be tree-shaken away when building for production since it's guarded with `ngDevMode`.
    // We're having the `try-catch` here because of the `SyncTestZoneSpec`, which throws
    // an error when micro or macrotask is used within a synchronous test. E.g. `Cannot call
    // Promise.then from within a sync test`.
    try {
        Promise.resolve().then((/**
         * @return {?}
         */
        () => {
            decorateFactory(constructor);
        }));
    }
    catch (_a) {
        // This is kind of a "hack", but we try to be backwards-compatible,
        // tho this `catch` block will only be executed when tests are run with Jasmine or Jest.
        ɵglobal.process &&
            ɵglobal.process.nextTick &&
            ɵglobal.process.nextTick((/**
             * @return {?}
             */
            () => {
                decorateFactory(constructor);
            }));
    }
}
/**
 * @record
 */
function Definition() { }
if (false) {
    /** @type {?} */
    Definition.prototype.factory;
}
/**
 * @record
 */
function ConstructorWithDefinitionAndFactory() { }
if (false) {
    /** @type {?|undefined} */
    ConstructorWithDefinitionAndFactory.prototype.ɵprov;
    /** @type {?|undefined} */
    ConstructorWithDefinitionAndFactory.prototype.ɵpipe;
    /** @type {?|undefined} */
    ConstructorWithDefinitionAndFactory.prototype.ɵcmp;
    /** @type {?|undefined} */
    ConstructorWithDefinitionAndFactory.prototype.ɵdir;
    /* Skipping unnamed member:
    [NG_FACTORY_DEF]?: Factory;*/
}
/**
 * @record
 */
function PrivateInstance() { }
if (false) {
    /* Skipping unnamed member:
    [InjectorInstance]?: Injector;*/
    /* Skipping unnamed member:
    [InjectorNotifier]?: ReplaySubject<boolean>;*/
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVjb3JhdG9yLWluamVjdG9yLWFkYXB0ZXIuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9Abmd4cy9zdG9yZS9pbnRlcm5hbHMvIiwic291cmNlcyI6WyJkZWNvcmF0b3ItaW5qZWN0b3ItYWRhcHRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUdMLFFBQVEsRUFFUixpQkFBaUIsRUFDakIsT0FBTyxFQUNSLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSxNQUFNLENBQUM7OztNQU8vQixjQUFjLEdBQUcsTUFBTTs7O01BR3ZCLGdCQUFnQixHQUFrQixNQUFNLENBQUMsa0JBQWtCLENBQUM7OztNQUc1RCx1QkFBdUIsR0FBa0IsTUFBTSxDQUFDLHlCQUF5QixDQUFDOzs7O01BSTFFLGdCQUFnQixHQUFrQixNQUFNLENBQUMsa0JBQWtCLENBQUM7Ozs7QUFFbEUsNENBRUM7Ozs7Ozs7OztBQUVELE1BQU0sVUFBVSxnQ0FBZ0MsQ0FDOUMsTUFBdUQ7SUFFdkQsSUFBSSxNQUFNLENBQUMsZ0JBQWdCLENBQUMsRUFBRTtRQUM1QixPQUFPLG1CQUFBLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxFQUFDLENBQUM7S0FDbEM7U0FBTTs7Y0FDQyxpQkFBaUIsR0FBRyxJQUFJLGFBQWEsQ0FBVSxDQUFDLENBQUM7UUFDdkQsTUFBTSxDQUFDLGNBQWMsQ0FBQyxNQUFNLEVBQUUsZ0JBQWdCLEVBQUU7WUFDOUMsR0FBRzs7O1lBQUUsR0FBRyxFQUFFLENBQUMsaUJBQWlCLENBQUE7U0FDN0IsQ0FBQyxDQUFDO1FBQ0gsT0FBTyxpQkFBaUIsQ0FBQztLQUMxQjtBQUNILENBQUM7Ozs7OztBQUdELE1BQU0sVUFBVSwyQkFBMkIsQ0FBQyxNQUFjO0lBQ3hELElBQUksdUJBQXVCLElBQUksTUFBTSxDQUFDLFdBQVcsQ0FBQyxTQUFTLEVBQUU7UUFDM0QsT0FBTztLQUNSOztVQUVLLFdBQVcsR0FBd0MsTUFBTSxDQUFD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VUM7OztJQVJDLG9EQUFtQjs7SUFFbkIsb0RBQW1COztJQUVuQixtREFBa0I7O0lBRWxCLG1EQUFrQjs7Ozs7OztBQUlwQiw4QkFHQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XHJcbiAgSW5qZWN0aW9uVG9rZW4sXHJcbiAgSW5qZWN0b3IsXHJcbiAgSU5KRUNUT1IsXHJcbiAgVHlwZSxcclxuICDJtcm1ZGlyZWN0aXZlSW5qZWN0LFxyXG4gIMm1Z2xvYmFsXHJcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IFJlcGxheVN1YmplY3QgfSBmcm9tICdyeGpzJztcclxuXHJcbi8vIFdpbGwgYmUgcHJvdmlkZWQgdGhyb3VnaCBUZXJzZXIgZ2xvYmFsIGRlZmluaXRpb25zIGJ5IEFuZ3VsYXIgQ0xJXHJcbi8vIGR1cmluZyB0aGUgcHJvZHVjdGlvbiBidWlsZC4gVGhpcyBpcyBob3cgQW5ndWxhciBkb2VzIHRyZWUtc2hha2luZyBpbnRlcm5hbGx5LlxyXG5kZWNsYXJlIGNvbnN0IG5nRGV2TW9kZTogYm9vbGVhbjtcclxuXHJcbi8vIEFuZ3VsYXIgZG9lc24ndCBleHBvcnQgYE5HX0ZBQ1RPUllfREVGYC5cclxuY29uc3QgTkdfRkFDVE9SWV9ERUYgPSAnybVmYWMnO1xyXG5cclxuLy8gQSBgU3ltYm9sYCB3aGljaCBpcyB1c2VkIHRvIHNhdmUgdGhlIGBJbmplY3RvcmAgb250byB0aGUgY2xhc3MgaW5zdGFuY2UuXHJcbmNvbnN0IEluamVjdG9ySW5zdGFuY2U6IHVuaXF1ZSBzeW1ib2wgPSBTeW1ib2woJ0luamVjdG9ySW5zdGFuY2UnKTtcclxuXHJcbi8vIEEgYFN5bWJvbGAgd2hpY2ggaXMgdXNlZCB0byBkZXRlcm1pbmUgaWYgZmFjdG9yeSBoYXMgYmVlbiBkZWNvcmF0ZWQgcHJldmlvdXNseSBvciBub3QuXHJcbmNvbnN0IEZhY3RvcnlIYXNCZWVuRGVjb3JhdGVkOiB1bmlxdWUgc3ltYm9sID0gU3ltYm9sKCdGYWN0b3J5SGFzQmVlbkRlY29yYXRlZCcpO1xyXG5cclxuLy8gQSBgU3ltYm9sYCB3aGljaCBpcyB1c2VkIHRvIHNhdmUgdGhlIG5vdGlmaWVyIG9uIHRoZSBjbGFzcyBpbnN0YW5jZS4gVGhlIGBJbmplY3Rvckluc3RhbmNlYCBjYW5ub3RcclxuLy8gYmUgcmV0cmlldmVkIHdpdGhpbiB0aGUgYGNvbnN0cnVjdG9yYCBzaW5jZSBpdCdzIHNldCBhZnRlciB0aGUgYGZhY3RvcnkoKWAgaXMgY2FsbGVkLlxyXG5jb25zdCBJbmplY3Rvck5vdGlmaWVyOiB1bmlxdWUgc3ltYm9sID0gU3ltYm9sKCdJbmplY3Rvck5vdGlmaWVyJyk7XHJcblxyXG5pbnRlcmZhY2UgUHJvdG90eXBlV2l0aEluamVjdG9yTm90aWZpZXIgZXh0ZW5kcyBPYmplY3Qge1xyXG4gIFtJbmplY3Rvck5vdGlmaWVyXT86IFJlcGxheVN1YmplY3Q8Ym9vbGVhbj47XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBlbnN1cmVJbmplY3Rvck5vdGlmaWVySXNDYXB0dXJlZChcclxuICB0YXJnZXQ6IFByb3RvdHlwZVdpdGhJbmplY3Rvck5vdGlmaWVyIHwgUHJpdmF0ZUluc3RhbmNlXHJcbik6IFJlcGxheVN1YmplY3Q8Ym9vbGVhbj4ge1xyXG4gIGlmICh0YXJnZXRbSW5qZWN0b3JOb3RpZmllcl0pIHtcclxuICAgIHJldHVybiB0YXJnZXRbSW5qZWN0b3JOb3RpZmllcl0hO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBjb25zdCBpbmplY3Rvck5vdGlmaWVyJCA9IG5ldyBSZXBsYXlTdWJqZWN0PGJvb2xlYW4+KDEpO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgSW5qZWN0b3JOb3RpZmllciwge1xyXG4gICAgICBnZXQ6ICgpID0+IGluamVjdG9yTm90aWZpZXIkXHJcbiAgICB9KTtcclxuICAgIHJldHVybiBpbmplY3Rvck5vdGlmaWVyJDtcclxuICB9XHJcbn1cclxuXHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXR5cGVzXHJcbmV4cG9ydCBmdW5jdGlvbiBlbnN1cmVMb2NhbEluamVjdG9yQ2FwdHVyZWQodGFyZ2V0OiBPYmplY3QpOiB2b2lkIHtcclxuICBpZiAoRmFjdG9yeUhhc0JlZW5EZWNvcmF0ZWQgaW4gdGFyZ2V0LmNvbnN0cnVjdG9yLnByb3RvdHlwZSkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgY29uc3RydWN0b3I6IENvbnN0cnVjdG9yV2l0aERlZmluaXRpb25BbmRGYWN0b3J5ID0gdGFyZ2V0LmNvbnN0cnVjdG9yO1xyXG4gIC8vIE1lYW5zIHdlJ3JlIGluIEFPVCBtb2RlLlxyXG4gIGlmICh0eXBlb2YgY29uc3RydWN0b3JbTkdfRkFDVE9SWV9ERUZdID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICBkZWNvcmF0ZUZhY3RvcnkoY29uc3RydWN0b3IpO1xyXG4gIH0gZWxzZSBpZiAobmdEZXZNb2RlKSB7XHJcbiAgICAvLyBXZSdyZSBydW5uaW5nIGluIEpJVCBtb2RlIGFuZCB0aGF0IG1lYW5zIHdlJ3JlIG5vdCBhYmxlIHRvIGdldCB0aGUgY29tcGlsZWQgZGVmaW5pdGlvblxyXG4gICAgLy8gb24gdGhlIGNsYXNzIGluc2lkZSB0aGUgcHJvcGVydHkgZGVjb3JhdG9yIGR1cmluZyB0aGUgY3VycmVudCBtZXNzYWdlIGxvb3AgdGljay4gV2UgaGF2ZVxyXG4gICAgLy8gdG8gd2FpdCBmb3IgdGhlIG5leHQgbWVzc2FnZSBsb29wIHRpY2suIE5vdGUgdGhhdCB0aGlzIGlzIHNhZmUgc2luY2UgdGhpcyBQcm9taXNlIHdpbGwgYmVcclxuICAgIC8vIHJlc29sdmVkIGV2ZW4gYmVmb3JlIHRoZSBgQVBQX0lOSVRJQUxJWkVSYCBpcyByZXNvbHZlZC5cclxuICAgIC8vIFRoZSBiZWxvdyBjb2RlIGFsc28gd2lsbCBiZSBleGVjdXRlZCBvbmx5IGluIGRldmVsb3BtZW50IG1vZGUsIHNpbmNlIGl0J3MgbmV2ZXIgcmVjb21tZW5kZWRcclxuICAgIC8vIHRvIHVzZSB0aGUgSklUIGNvbXBpbGVyIGluIHByb2R1Y3Rpb24gbW9kZSAoYnkgc2V0dGluZyBcImFvdDogZmFsc2VcIikuXHJcbiAgICBkZWNvcmF0ZUZhY3RvcnlMYXRlcihjb25zdHJ1Y3Rvcik7XHJcbiAgfVxyXG5cclxuICB0YXJnZXQuY29uc3RydWN0b3IucHJvdG90eXBlW0ZhY3RvcnlIYXNCZWVuRGVjb3JhdGVkXSA9IHRydWU7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBsb2NhbEluamVjdDxUPihcclxuICBpbnN0YW5jZTogUHJpdmF0ZUluc3RhbmNlLFxyXG4gIHRva2VuOiBJbmplY3Rpb25Ub2tlbjxUPiB8IFR5cGU8VD5cclxuKTogVCB8IG51bGwge1xyXG4gIGNvbnN0IGluamVjdG9yOiBJbmplY3RvciB8IHVuZGVmaW5lZCA9IGluc3RhbmNlW0luamVjdG9ySW5zdGFuY2VdO1xyXG4gIHJldHVybiBpbmplY3RvciA/IGluamVjdG9yLmdldCh0b2tlbikgOiBudWxsO1xyXG59XHJcblxyXG5mdW5jdGlvbiBkZWNvcmF0ZUZhY3RvcnkoY29uc3RydWN0b3I6IENvbnN0cnVjdG9yV2l0aERlZmluaXRpb25BbmRGYWN0b3J5KTogdm9pZCB7XHJcbiAgY29uc3QgZmFjdG9yeSA9IGNvbnN0cnVjdG9yW05HX0ZBQ1RPUllfREVGXTtcclxuXHJcbiAgaWYgKHR5cGVvZiBmYWN0b3J5ICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICAvLyBMZXQncyB0cnkgdG8gZ2V0IGFueSBkZWZpbml0aW9uLlxyXG4gIC8vIENhcmV0YWtlciBub3RlOiB0aGlzIHdpbGwgYmUgY29tcGF0aWJsZSBvbmx5IHdpdGggQW5ndWxhciA5Kywgc2luY2UgQW5ndWxhciA5IGlzIHRoZSBmaXJzdFxyXG4gIC8vIEl2eS1zdGFibGUgdmVyc2lvbi4gUHJldmlvdXNseSBkZWZpbml0aW9uIHByb3BlcnRpZXMgd2VyZSBuYW1lZCBkaWZmZXJlbnRseSAoZS5nLiBgbmdDb21wb25lbnREZWZgKS5cclxuICBjb25zdCBkZWYgPSBjb25zdHJ1Y3Rvci7JtXByb3YgfHwgY29uc3RydWN0b3IuybVwaXBlIHx8IGNvbnN0cnVjdG9yLsm1Y21wIHx8IGNvbnN0cnVjdG9yLsm1ZGlyO1xyXG5cclxuICBjb25zdCBkZWNvcmF0ZWRGYWN0b3J5ID0gKCkgPT4ge1xyXG4gICAgY29uc3QgaW5zdGFuY2UgPSBmYWN0b3J5KCk7XHJcbiAgICAvLyBDYXJldGFrZXIgbm90ZTogYGluamVjdCgpYCB3b24ndCB3b3JrIGhlcmUuXHJcbiAgICAvLyBXZSBjYW4gdXNlIHRoZSBgZGlyZWN0aXZlSW5qZWN0YCBvbmx5IGR1cmluZyB0aGUgY29tcG9uZW50XHJcbiAgICAvLyBjb25zdHJ1Y3Rpb24sIHNpbmNlIEFuZ3VsYXIgY2FwdHVyZXMgdGhlIGN1cnJlbnRseSBhY3RpdmUgaW5qZWN0b3IuXHJcbiAgICAvLyBXZSdyZSBub3QgYWJsZSB0byB1c2UgdGhpcyBmdW5jdGlvbiBpbnNpZGUgdGhlIGdldHRlciAod2hlbiB0aGUgYHNlbGVjdG9ySWRgIHByb3BlcnR5IGlzXHJcbiAgICAvLyByZXF1ZXN0ZWQgZm9yIHRoZSBmaXJzdCB0aW1lKSwgc2luY2UgdGhlIGN1cnJlbnRseSBhY3RpdmUgaW5qZWN0b3Igd2lsbCBiZSBudWxsLlxyXG4gICAgaW5zdGFuY2VbSW5qZWN0b3JJbnN0YW5jZV0gPSDJtcm1ZGlyZWN0aXZlSW5qZWN0KFxyXG4gICAgICAvLyBXZSdyZSB1c2luZyBgSU5KRUNUT1JgIHRva2VuIGV4Y2VwdCBvZiB0aGUgYEluamVjdG9yYCBjbGFzcyBzaW5jZSB0aGUgY29tcGlsZXJcclxuICAgICAgLy8gdGhyb3dzOiBgQ2Fubm90IGFzc2lnbiBhbiBhYnN0cmFjdCBjb25zdHJ1Y3RvciB0eXBlIHRvIGEgbm9uLWFic3RyYWN0IGNvbnN0cnVjdG9yIHR5cGUuYC5cclxuICAgICAgLy8gQ2FyZXRha2VyIG5vdGU6IHRoYXQgdGhpcyBpcyB0aGUgc2FtZSB3YXkgb2YgZ2V0dGluZyB0aGUgaW5qZWN0b3IuXHJcbiAgICAgIElOSkVDVE9SXHJcbiAgICApO1xyXG5cclxuICAgIC8vIENhcmV0YWtlciBub3RlOiB0aGUgbm90aWZpZXIgd2lsbCBiZSBhdmFpbGFibGUgb25seSBpZiBjb25zdW1lcnMgY2FsbCB0aGUgYGVuc3VyZUluamVjdG9yTm90aWZpZXJJc0NhcHR1cmVkKClgLlxyXG4gICAgY29uc3QgaW5qZWN0b3JOb3RpZmllciQgPSBpbnN0YW5jZVtJbmplY3Rvck5vdGlmaWVyXTtcclxuICAgIGlmIChpbmplY3Rvck5vdGlmaWVyJCkge1xyXG4gICAgICBpbmplY3Rvck5vdGlmaWVyJC5uZXh0KHRydWUpO1xyXG4gICAgICBpbmplY3Rvck5vdGlmaWVyJC5jb21wbGV0ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBpbnN0YW5jZTtcclxuICB9O1xyXG5cclxuICAvLyBJZiB3ZSd2ZSBmb3VuZCBhbnkgZGVmaW5pdGlvbiB0aGVuIGl0J3MgZW5vdWdoIHRvIG92ZXJyaWRlIHRoZSBgZGVmLmZhY3RvcnlgIHNpbmNlIEFuZ3VsYXJcclxuICAvLyBjb2RlIHVzZXMgdGhlIGBkZWYuZmFjdG9yeWAgYW5kIHRoZW4gZmFsbGJhY2tzIHRvIGDJtWZhY2AuXHJcbiAgaWYgKGRlZikge1xyXG4gICAgZGVmLmZhY3RvcnkgPSBkZWNvcmF0ZWRGYWN0b3J5O1xyXG4gIH1cclxuXHJcbiAgLy8gYEBOZ01vZHVsZSgpYCBkb2Vzbid0IGRvZXNuJ3QgaGF2ZSBkZWZpbml0aW9uIGZhY3RvcnksIGFsc28gcHJvdmlkZXJzIGhhdmUgZGVmaW5pdGlvbnMgYnV0IEFuZ3VsYXJcclxuICAvLyBzdGlsbCB1c2VzIHRoZSBgybVmYWNgLlxyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb25zdHJ1Y3RvciwgTkdfRkFDVE9SWV9ERUYsIHtcclxuICAgIGdldDogKCkgPT4gZGVjb3JhdGVkRmFjdG9yeVxyXG4gIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBkZWNvcmF0ZUZhY3RvcnlMYXRlcihjb25zdHJ1Y3RvcjogQ29uc3RydWN0b3JXaXRoRGVmaW5pdGlvbkFuZEZhY3RvcnkpOiB2b2lkIHtcclxuICAvLyBUaGlzIGZ1bmN0aW9uIGFjdHVhbGx5IHdpbGwgYmUgdHJlZS1zaGFrZW4gYXdheSB3aGVuIGJ1aWxkaW5nIGZvciBwcm9kdWN0aW9uIHNpbmNlIGl0J3MgZ3VhcmRlZCB3aXRoIGBuZ0Rldk1vZGVgLlxyXG4gIC8vIFdlJ3JlIGhhdmluZyB0aGUgYHRyeS1jYXRjaGAgaGVyZSBiZWNhdXNlIG9mIHRoZSBgU3luY1Rlc3Rab25lU3BlY2AsIHdoaWNoIHRocm93c1xyXG4gIC8vIGFuIGVycm9yIHdoZW4gbWljcm8gb3IgbWFjcm90YXNrIGlzIHVzZWQgd2l0aGluIGEgc3luY2hyb25vdXMgdGVzdC4gRS5nLiBgQ2Fubm90IGNhbGxcclxuICAvLyBQcm9taXNlLnRoZW4gZnJvbSB3aXRoaW4gYSBzeW5jIHRlc3RgLlxyXG4gIHRyeSB7XHJcbiAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcclxuICAgICAgZGVjb3JhdGVGYWN0b3J5KGNvbnN0cnVjdG9yKTtcclxuICAgIH0pO1xyXG4gIH0gY2F0Y2gge1xyXG4gICAgLy8gVGhpcyBpcyBraW5kIG9mIGEgXCJoYWNrXCIsIGJ1dCB3ZSB0cnkgdG8gYmUgYmFja3dhcmRzLWNvbXBhdGlibGUsXHJcbiAgICAvLyB0aG8gdGhpcyBgY2F0Y2hgIGJsb2NrIHdpbGwgb25seSBiZSBleGVjdXRlZCB3aGVuIHRlc3RzIGFyZSBydW4gd2l0aCBKYXNtaW5lIG9yIEplc3QuXHJcbiAgICDJtWdsb2JhbC5wcm9jZXNzICYmXHJcbiAgICAgIMm1Z2xvYmFsLnByb2Nlc3MubmV4dFRpY2sgJiZcclxuICAgICAgybVnbG9iYWwucHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XHJcbiAgICAgICAgZGVjb3JhdGVGYWN0b3J5KGNvbnN0cnVjdG9yKTtcclxuICAgICAgfSk7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBXZSBjb3VsZCd2ZSB1c2VkIGDJtcm1RmFjdG9yeURlZmAgYnV0IHdlIHRyeSB0byBiZSBiYWNrd2FyZHMtY29tcGF0aWJsZSxcclxuLy8gc2luY2UgaXQncyBub3QgZXhwb3J0ZWQgaW4gb2xkZXIgQW5ndWxhciB2ZXJzaW9ucy5cclxudHlwZSBGYWN0b3J5ID0gKCkgPT4gUHJpdmF0ZUluc3RhbmNlO1xyXG5cclxuLy8gV2UgY291bGQndmUgdXNlZCBgybXJtUluamVjdGFibGVEZWZgLCBgybXJtVBpcGVEZWZgLCBldGMuIFdlIHRyeSB0byBiZSBiYWNrd2FyZHMtY29tcGF0aWJsZVxyXG4vLyBzaW5jZSB0aGV5J3JlIG5vdCBleHBvcnRlZCBpbiBvbGRlciBBbmd1bGFyIHZlcnNpb25zLlxyXG5pbnRlcmZhY2UgRGVmaW5pdGlvbiB7XHJcbiAgZmFjdG9yeTogRmFjdG9yeSB8IG51bGw7XHJcbn1cclxuXHJcbmludGVyZmFjZSBDb25zdHJ1Y3RvcldpdGhEZWZpbml0aW9uQW5kRmFjdG9yeSBleHRlbmRzIEZ1bmN0aW9uIHtcclxuICAvLyBQcm92aWRlciBkZWZpbml0aW9uIGZvciB0aGUgYEBJbmplY3RhYmxlKClgIGNsYXNzLlxyXG4gIMm1cHJvdj86IERlZmluaXRpb247XHJcbiAgLy8gUGlwZSBkZWZpbml0aW9uIGZvciB0aGUgYEBQaXBlKClgIGNsYXNzLlxyXG4gIMm1cGlwZT86IERlZmluaXRpb247XHJcbiAgLy8gQ29tcG9uZW50IGRlZmluaXRpb24gZm9yIHRoZSBgQENvbXBvbmVudCgpYCBjbGFzcy5cclxuICDJtWNtcD86IERlZmluaXRpb247XHJcbiAgLy8gRGlyZWN0aXZlIGRlZmluaXRpb24gZm9yIHRoZSBgQERpcmVjdGl2ZSgpYCBjbGFzcy5cclxuICDJtWRpcj86IERlZmluaXRpb247XHJcbiAgW05HX0ZBQ1RPUllfREVGXT86IEZhY3Rvcnk7XHJcbn1cclxuXHJcbmludGVyZmFjZSBQcml2YXRlSW5zdGFuY2Uge1xyXG4gIFtJbmplY3Rvckluc3RhbmNlXT86IEluamVjdG9yO1xyXG4gIFtJbmplY3Rvck5vdGlmaWVyXT86IFJlcGxheVN1YmplY3Q8Ym9vbGVhbj47XHJcbn1cclxuIl19