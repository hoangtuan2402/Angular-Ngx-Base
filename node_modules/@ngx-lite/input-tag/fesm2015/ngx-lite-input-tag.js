import * as i0 from '@angular/core';
import { InjectionToken, EventEmitter, forwardRef, Component, ChangeDetectionStrategy, ViewEncapsulation, Inject, ViewChild, Input, Output, HostListener, NgModule } from '@angular/core';
import { NG_VALUE_ACCESSOR, NG_VALIDATORS } from '@angular/forms';
import * as i1 from '@angular/common';
import { CommonModule } from '@angular/common';

const NGX_INPUT_TAG_TAG_FORMATTER = new InjectionToken('NGX_INPUT_TAG_TAG_FORMATTER');

var KeyCodes;
(function (KeyCodes) {
    KeyCodes[KeyCodes["Backspace"] = 8] = "Backspace";
    KeyCodes[KeyCodes["Tab"] = 9] = "Tab";
    KeyCodes[KeyCodes["Enter"] = 13] = "Enter";
    KeyCodes[KeyCodes["Escape"] = 27] = "Escape";
    KeyCodes[KeyCodes["LeftArrow"] = 37] = "LeftArrow";
    KeyCodes[KeyCodes["UpArrow"] = 38] = "UpArrow";
    KeyCodes[KeyCodes["RightArrow"] = 39] = "RightArrow";
    KeyCodes[KeyCodes["DownArrow"] = 40] = "DownArrow";
    KeyCodes[KeyCodes["Comma"] = 188] = "Comma";
})(KeyCodes || (KeyCodes = {}));
class NgxInputTagComponent {
    constructor(tagFormatter) {
        this.tagFormatter = tagFormatter;
        this.tagSuggestions = [];
        this.maxTagLength = 25;
        this.maxNumberOfTags = 1000;
        this.textChange = new EventEmitter();
        this._value = [];
        this.prevTagInput = '';
        this.currentNumberOfTags = 0;
        this.tagError = null;
        this.onChange = (_value) => { };
        this.onTouched = () => { };
    }
    get value() {
        return this._value;
    }
    set value(val) {
        this._value = val;
        this.onChange(val);
        this.onTouched();
    }
    registerOnChange(fn) {
        this.onChange = fn;
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    writeValue(value) {
        if (value) {
            this.value = value.map((v) => this.tagFormatter(v));
            this.setCurrentNumberOfTags();
        }
    }
    validate() {
        return this.tagError;
    }
    handleClick(event) {
        if (this.inputElement &&
            !this.inputElement.nativeElement.contains(event.target) &&
            this.inputElement.nativeElement.value) {
            this.addTag(this.inputElement.nativeElement.value);
        }
    }
    addTag(tag) {
        const formattedTag = this.tagFormatter(tag);
        const tagIsEmpty = formattedTag.length === 0;
        const invalidTagLength = !formattedTag.length ||
            (this.maxTagLength && formattedTag.length > this.maxTagLength);
        const duplicateTag = this.value.indexOf(formattedTag) > -1;
        const exceedsMaxNumberOfTags = this.currentNumberOfTags > this.maxNumberOfTags;
        if (!tagIsEmpty && invalidTagLength) {
            this.tagError = {
                message: `Tag length cannot exceed ${this.maxTagLength} characters`,
            };
        }
        if (duplicateTag) {
            this.tagError = { message: 'Cannot add duplicate tag' };
        }
        if (exceedsMaxNumberOfTags) {
            const plural = this.maxNumberOfTags === 1 ? '' : 's';
            this.tagError = {
                message: `Cannot exceed ${this.maxNumberOfTags} tag${plural}`,
            };
        }
        if (!tagIsEmpty &&
            !invalidTagLength &&
            !duplicateTag &&
            !exceedsMaxNumberOfTags &&
            this.inputElement) {
            this.tagError = null;
            this.value.push(formattedTag);
            this.setCurrentNumberOfTags();
            this.inputElement.nativeElement.value = '';
        }
        this.value = this.value;
        this.focus();
    }
    addTagEvent(event) {
        const input = event.target;
        this.tagError = null;
        this.value = this.value;
        this.textChange.emit(input.value);
        if (event.keyCode === KeyCodes.Backspace &&
            this.prevTagInput.length === 0) {
            this._value.pop();
            this.setCurrentNumberOfTags();
        }
        else if (event.keyCode === KeyCodes.Enter ||
            event.keyCode === KeyCodes.Comma ||
            event.keyCode === KeyCodes.Tab) {
            this.addTag(input.value);
        }
        this.prevTagInput = input.value;
    }
    preventDefaultTabBehavior(event) {
        if (event.keyCode === KeyCodes.Tab && this.prevTagInput.length > 0) {
            event.preventDefault();
        }
    }
    addTagClick(event, value) {
        event.preventDefault();
        if (value.length > 0) {
            this.addTag(value);
        }
    }
    addSuggestedTag(tag) {
        this.addTag(tag);
    }
    removeTag(tag, event) {
        if (event.keyCode !== KeyCodes.Enter) {
            this.value = this._value.filter((t) => t !== tag);
            this.setCurrentNumberOfTags();
        }
    }
    focus() {
        var _a;
        (_a = this.inputElement) === null || _a === void 0 ? void 0 : _a.nativeElement.focus();
    }
    setCurrentNumberOfTags() {
        this.currentNumberOfTags = this.value.length
            ? this.value.toString().split(',').length
            : 0;
    }
}
NgxInputTagComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0, type: NgxInputTagComponent, deps: [{ token: NGX_INPUT_TAG_TAG_FORMATTER }], target: i0.ɵɵFactoryTarget.Component });
NgxInputTagComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.2", type: NgxInputTagComponent, selector: "ngx-input-tag", inputs: { tagSuggestions: "tagSuggestions", maxTagLength: "maxTagLength", maxNumberOfTags: "maxNumberOfTags" }, outputs: { textChange: "textChange" }, host: { listeners: { "document:click": "handleClick($event)" } }, providers: [
        {
            provide: NG_VALUE_ACCESSOR,
            useExisting: forwardRef(() => NgxInputTagComponent),
            multi: true,
        },
        {
            provide: NG_VALIDATORS,
            useExisting: forwardRef(() => NgxInputTagComponent),
            multi: true,
        },
    ], viewQueries: [{ propertyName: "inputElement", first: true, predicate: ["inputElement"], descendants: true }], ngImport: i0, template: "<div (click)=\"focus()\" class=\"ngx-input-tag\">\n  <div *ngFor=\"let tag of value\" class=\"ngx-input-tag__tag\">\n    {{tag}}\n    <button type=\"button\" (click)=\"removeTag(tag, $event)\">\n      &#10006;\n    </button>\n  </div>\n  <input type=\"text\" #inputElement aria-label=\"Tags\" [style.width]=\"inputElement.value.length * 10 + 10 + 'px'\" (keyup)=\"addTagEvent($event)\" (keydown)=\"preventDefaultTabBehavior($event)\"\n    class=\"ngx-input-tag__input\" />\n  <button type=\"button\" aria-label=\"Add Tag\" title=\"Add Tag\" (click)=\"addTagClick($event, inputElement.value)\" class=\"ngx-input-tag__btn\">\n    +\n  </button>\n</div>\n\n<div *ngIf=\"inputElement.value.length && tagSuggestions && tagSuggestions.length\" class=\"ngx-input-tag-suggestions\">\n  <button type=\"button\" (click)=\"addSuggestedTag(tag)\" *ngFor=\"let tag of tagSuggestions\" class=\"ngx-input-tag-suggestions__tag\">{{tag}}</button>\n</div>", styles: ["*,:after,:before{box-sizing:border-box}ngx-input-tag{display:inline-block;margin-bottom:12px;width:100%;--color-border:#dbdbdb;--color-background:#fff;--color-tag-close:#ccc;--color-add-button:#ccc;--color-add-button-background:#fff;--color-tag-suggestion-hover:#f2f2f2}.ngx-input-tag{padding:5px 80px 4.5px 4px;position:relative;margin-bottom:0;border:1px solid #dbdbdb;border:1px solid var(--color-border);background-color:#fff;background-color:var(--color-background);font-size:16px}.ngx-input-tag:focus{outline:initial}.ngx-input-tag__input{border:0;padding:4px 0;outline:none;width:8px;max-width:calc(100% + 70px);margin-left:4px;min-width:4px;margin-bottom:0;font-size:16px;min-height:29px}.ngx-input-tag__tag{display:inline-block;border:1px solid #dbdbdb;border:1px solid var(--color-border);padding:4px;margin-right:4px;border-radius:2px;height:29px;line-height:18px}.ngx-input-tag__tag button{background:#0000;border:0;cursor:pointer;color:var(--color-tag-close)}.ngx-input-tag__btn{position:absolute;width:50px;height:41px;color:#ccc;color:var(--color-add-button);background-color:#fff;background-color:var(--color-add-button-background);top:-1px;right:-1px;cursor:pointer;font-size:30px}.ngx-input-tag-suggestions,.ngx-input-tag__btn{border:1px solid #dbdbdb;border:1px solid var(--color-border)}.ngx-input-tag-suggestions{background-color:#fff;background-color:var(--color-background)}.ngx-input-tag-suggestions__tag{padding:10px 14px;border:0;background:#0000;display:block;cursor:pointer;width:100%;text-align:left}.ngx-input-tag-suggestions__tag:hover{background:#f2f2f2;background:var(--color-tag-suggestion-hover)}"], directives: [{ type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0, type: NgxInputTagComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'ngx-input-tag',
                    templateUrl: './ngx-input-tag.component.html',
                    styleUrls: ['./ngx-input-tag.component.scss'],
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: forwardRef(() => NgxInputTagComponent),
                            multi: true,
                        },
                        {
                            provide: NG_VALIDATORS,
                            useExisting: forwardRef(() => NgxInputTagComponent),
                            multi: true,
                        },
                    ],
                    encapsulation: ViewEncapsulation.None,
                }]
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [NGX_INPUT_TAG_TAG_FORMATTER]
                }] }]; }, propDecorators: { inputElement: [{
                type: ViewChild,
                args: ['inputElement', { static: false }]
            }], tagSuggestions: [{
                type: Input
            }], maxTagLength: [{
                type: Input
            }], maxNumberOfTags: [{
                type: Input
            }], textChange: [{
                type: Output
            }], handleClick: [{
                type: HostListener,
                args: ['document:click', ['$event']]
            }] } });
function formatter(tag) {
    return tag
        .trim()
        .replace(/(\s|-)+/g, '-')
        .replace(/\,/g, '')
        .toLowerCase();
}

class NgxInputTagModule {
    static forRoot(config = { tagFormatter: formatter }) {
        return {
            ngModule: NgxInputTagModule,
            providers: [
                {
                    provide: NGX_INPUT_TAG_TAG_FORMATTER,
                    useValue: config.tagFormatter,
                },
            ],
        };
    }
}
NgxInputTagModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0, type: NgxInputTagModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
NgxInputTagModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0, type: NgxInputTagModule, declarations: [NgxInputTagComponent], imports: [CommonModule], exports: [NgxInputTagComponent] });
NgxInputTagModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0, type: NgxInputTagModule, imports: [[CommonModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0, type: NgxInputTagModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [NgxInputTagComponent],
                    exports: [NgxInputTagComponent],
                }]
        }] });

/*
 * Public API Surface of ngx-input-tag
 */

/**
 * Generated bundle index. Do not edit.
 */

export { KeyCodes, NGX_INPUT_TAG_TAG_FORMATTER, NgxInputTagComponent, NgxInputTagModule, formatter };
//# sourceMappingURL=ngx-lite-input-tag.js.map
