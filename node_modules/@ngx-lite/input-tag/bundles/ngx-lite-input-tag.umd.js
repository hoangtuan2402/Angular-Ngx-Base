(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/forms'), require('@angular/common')) :
    typeof define === 'function' && define.amd ? define('@ngx-lite/input-tag', ['exports', '@angular/core', '@angular/forms', '@angular/common'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global['ngx-lite'] = global['ngx-lite'] || {}, global['ngx-lite']['input-tag'] = {}), global.ng.core, global.ng.forms, global.ng.common));
}(this, (function (exports, i0, forms, i1) { 'use strict';

    function _interopNamespace(e) {
        if (e && e.__esModule) return e;
        var n = Object.create(null);
        if (e) {
            Object.keys(e).forEach(function (k) {
                if (k !== 'default') {
                    var d = Object.getOwnPropertyDescriptor(e, k);
                    Object.defineProperty(n, k, d.get ? d : {
                        enumerable: true,
                        get: function () {
                            return e[k];
                        }
                    });
                }
            });
        }
        n['default'] = e;
        return Object.freeze(n);
    }

    var i0__namespace = /*#__PURE__*/_interopNamespace(i0);
    var i1__namespace = /*#__PURE__*/_interopNamespace(i1);

    var NGX_INPUT_TAG_TAG_FORMATTER = new i0.InjectionToken('NGX_INPUT_TAG_TAG_FORMATTER');

    exports.KeyCodes = void 0;
    (function (KeyCodes) {
        KeyCodes[KeyCodes["Backspace"] = 8] = "Backspace";
        KeyCodes[KeyCodes["Tab"] = 9] = "Tab";
        KeyCodes[KeyCodes["Enter"] = 13] = "Enter";
        KeyCodes[KeyCodes["Escape"] = 27] = "Escape";
        KeyCodes[KeyCodes["LeftArrow"] = 37] = "LeftArrow";
        KeyCodes[KeyCodes["UpArrow"] = 38] = "UpArrow";
        KeyCodes[KeyCodes["RightArrow"] = 39] = "RightArrow";
        KeyCodes[KeyCodes["DownArrow"] = 40] = "DownArrow";
        KeyCodes[KeyCodes["Comma"] = 188] = "Comma";
    })(exports.KeyCodes || (exports.KeyCodes = {}));
    var NgxInputTagComponent = /** @class */ (function () {
        function NgxInputTagComponent(tagFormatter) {
            this.tagFormatter = tagFormatter;
            this.tagSuggestions = [];
            this.maxTagLength = 25;
            this.maxNumberOfTags = 1000;
            this.textChange = new i0.EventEmitter();
            this._value = [];
            this.prevTagInput = '';
            this.currentNumberOfTags = 0;
            this.tagError = null;
            this.onChange = function (_value) { };
            this.onTouched = function () { };
        }
        Object.defineProperty(NgxInputTagComponent.prototype, "value", {
            get: function () {
                return this._value;
            },
            set: function (val) {
                this._value = val;
                this.onChange(val);
                this.onTouched();
            },
            enumerable: false,
            configurable: true
        });
        NgxInputTagComponent.prototype.registerOnChange = function (fn) {
            this.onChange = fn;
        };
        NgxInputTagComponent.prototype.registerOnTouched = function (fn) {
            this.onTouched = fn;
        };
        NgxInputTagComponent.prototype.writeValue = function (value) {
            var _this = this;
            if (value) {
                this.value = value.map(function (v) { return _this.tagFormatter(v); });
                this.setCurrentNumberOfTags();
            }
        };
        NgxInputTagComponent.prototype.validate = function () {
            return this.tagError;
        };
        NgxInputTagComponent.prototype.handleClick = function (event) {
            if (this.inputElement &&
                !this.inputElement.nativeElement.contains(event.target) &&
                this.inputElement.nativeElement.value) {
                this.addTag(this.inputElement.nativeElement.value);
            }
        };
        NgxInputTagComponent.prototype.addTag = function (tag) {
            var formattedTag = this.tagFormatter(tag);
            var tagIsEmpty = formattedTag.length === 0;
            var invalidTagLength = !formattedTag.length ||
                (this.maxTagLength && formattedTag.length > this.maxTagLength);
            var duplicateTag = this.value.indexOf(formattedTag) > -1;
            var exceedsMaxNumberOfTags = this.currentNumberOfTags > this.maxNumberOfTags;
            if (!tagIsEmpty && invalidTagLength) {
                this.tagError = {
                    message: "Tag length cannot exceed " + this.maxTagLength + " characters",
                };
            }
            if (duplicateTag) {
                this.tagError = { message: 'Cannot add duplicate tag' };
            }
            if (exceedsMaxNumberOfTags) {
                var plural = this.maxNumberOfTags === 1 ? '' : 's';
                this.tagError = {
                    message: "Cannot exceed " + this.maxNumberOfTags + " tag" + plural,
                };
            }
            if (!tagIsEmpty &&
                !invalidTagLength &&
                !duplicateTag &&
                !exceedsMaxNumberOfTags &&
                this.inputElement) {
                this.tagError = null;
                this.value.push(formattedTag);
                this.setCurrentNumberOfTags();
                this.inputElement.nativeElement.value = '';
            }
            this.value = this.value;
            this.focus();
        };
        NgxInputTagComponent.prototype.addTagEvent = function (event) {
            var input = event.target;
            this.tagError = null;
            this.value = this.value;
            this.textChange.emit(input.value);
            if (event.keyCode === exports.KeyCodes.Backspace &&
                this.prevTagInput.length === 0) {
                this._value.pop();
                this.setCurrentNumberOfTags();
            }
            else if (event.keyCode === exports.KeyCodes.Enter ||
                event.keyCode === exports.KeyCodes.Comma ||
                event.keyCode === exports.KeyCodes.Tab) {
                this.addTag(input.value);
            }
            this.prevTagInput = input.value;
        };
        NgxInputTagComponent.prototype.preventDefaultTabBehavior = function (event) {
            if (event.keyCode === exports.KeyCodes.Tab && this.prevTagInput.length > 0) {
                event.preventDefault();
            }
        };
        NgxInputTagComponent.prototype.addTagClick = function (event, value) {
            event.preventDefault();
            if (value.length > 0) {
                this.addTag(value);
            }
        };
        NgxInputTagComponent.prototype.addSuggestedTag = function (tag) {
            this.addTag(tag);
        };
        NgxInputTagComponent.prototype.removeTag = function (tag, event) {
            if (event.keyCode !== exports.KeyCodes.Enter) {
                this.value = this._value.filter(function (t) { return t !== tag; });
                this.setCurrentNumberOfTags();
            }
        };
        NgxInputTagComponent.prototype.focus = function () {
            var _a;
            (_a = this.inputElement) === null || _a === void 0 ? void 0 : _a.nativeElement.focus();
        };
        NgxInputTagComponent.prototype.setCurrentNumberOfTags = function () {
            this.currentNumberOfTags = this.value.length
                ? this.value.toString().split(',').length
                : 0;
        };
        return NgxInputTagComponent;
    }());
    NgxInputTagComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0__namespace, type: NgxInputTagComponent, deps: [{ token: NGX_INPUT_TAG_TAG_FORMATTER }], target: i0__namespace.ɵɵFactoryTarget.Component });
    NgxInputTagComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.2", type: NgxInputTagComponent, selector: "ngx-input-tag", inputs: { tagSuggestions: "tagSuggestions", maxTagLength: "maxTagLength", maxNumberOfTags: "maxNumberOfTags" }, outputs: { textChange: "textChange" }, host: { listeners: { "document:click": "handleClick($event)" } }, providers: [
            {
                provide: forms.NG_VALUE_ACCESSOR,
                useExisting: i0.forwardRef(function () { return NgxInputTagComponent; }),
                multi: true,
            },
            {
                provide: forms.NG_VALIDATORS,
                useExisting: i0.forwardRef(function () { return NgxInputTagComponent; }),
                multi: true,
            },
        ], viewQueries: [{ propertyName: "inputElement", first: true, predicate: ["inputElement"], descendants: true }], ngImport: i0__namespace, template: "<div (click)=\"focus()\" class=\"ngx-input-tag\">\n  <div *ngFor=\"let tag of value\" class=\"ngx-input-tag__tag\">\n    {{tag}}\n    <button type=\"button\" (click)=\"removeTag(tag, $event)\">\n      &#10006;\n    </button>\n  </div>\n  <input type=\"text\" #inputElement aria-label=\"Tags\" [style.width]=\"inputElement.value.length * 10 + 10 + 'px'\" (keyup)=\"addTagEvent($event)\" (keydown)=\"preventDefaultTabBehavior($event)\"\n    class=\"ngx-input-tag__input\" />\n  <button type=\"button\" aria-label=\"Add Tag\" title=\"Add Tag\" (click)=\"addTagClick($event, inputElement.value)\" class=\"ngx-input-tag__btn\">\n    +\n  </button>\n</div>\n\n<div *ngIf=\"inputElement.value.length && tagSuggestions && tagSuggestions.length\" class=\"ngx-input-tag-suggestions\">\n  <button type=\"button\" (click)=\"addSuggestedTag(tag)\" *ngFor=\"let tag of tagSuggestions\" class=\"ngx-input-tag-suggestions__tag\">{{tag}}</button>\n</div>", styles: ["*,:after,:before{box-sizing:border-box}ngx-input-tag{display:inline-block;margin-bottom:12px;width:100%;--color-border:#dbdbdb;--color-background:#fff;--color-tag-close:#ccc;--color-add-button:#ccc;--color-add-button-background:#fff;--color-tag-suggestion-hover:#f2f2f2}.ngx-input-tag{padding:5px 80px 4.5px 4px;position:relative;margin-bottom:0;border:1px solid #dbdbdb;border:1px solid var(--color-border);background-color:#fff;background-color:var(--color-background);font-size:16px}.ngx-input-tag:focus{outline:initial}.ngx-input-tag__input{border:0;padding:4px 0;outline:none;width:8px;max-width:calc(100% + 70px);margin-left:4px;min-width:4px;margin-bottom:0;font-size:16px;min-height:29px}.ngx-input-tag__tag{display:inline-block;border:1px solid #dbdbdb;border:1px solid var(--color-border);padding:4px;margin-right:4px;border-radius:2px;height:29px;line-height:18px}.ngx-input-tag__tag button{background:#0000;border:0;cursor:pointer;color:var(--color-tag-close)}.ngx-input-tag__btn{position:absolute;width:50px;height:41px;color:#ccc;color:var(--color-add-button);background-color:#fff;background-color:var(--color-add-button-background);top:-1px;right:-1px;cursor:pointer;font-size:30px}.ngx-input-tag-suggestions,.ngx-input-tag__btn{border:1px solid #dbdbdb;border:1px solid var(--color-border)}.ngx-input-tag-suggestions{background-color:#fff;background-color:var(--color-background)}.ngx-input-tag-suggestions__tag{padding:10px 14px;border:0;background:#0000;display:block;cursor:pointer;width:100%;text-align:left}.ngx-input-tag-suggestions__tag:hover{background:#f2f2f2;background:var(--color-tag-suggestion-hover)}"], directives: [{ type: i1__namespace.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i1__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush, encapsulation: i0__namespace.ViewEncapsulation.None });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0__namespace, type: NgxInputTagComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'ngx-input-tag',
                        templateUrl: './ngx-input-tag.component.html',
                        styleUrls: ['./ngx-input-tag.component.scss'],
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        providers: [
                            {
                                provide: forms.NG_VALUE_ACCESSOR,
                                useExisting: i0.forwardRef(function () { return NgxInputTagComponent; }),
                                multi: true,
                            },
                            {
                                provide: forms.NG_VALIDATORS,
                                useExisting: i0.forwardRef(function () { return NgxInputTagComponent; }),
                                multi: true,
                            },
                        ],
                        encapsulation: i0.ViewEncapsulation.None,
                    }]
            }], ctorParameters: function () {
            return [{ type: undefined, decorators: [{
                            type: i0.Inject,
                            args: [NGX_INPUT_TAG_TAG_FORMATTER]
                        }] }];
        }, propDecorators: { inputElement: [{
                    type: i0.ViewChild,
                    args: ['inputElement', { static: false }]
                }], tagSuggestions: [{
                    type: i0.Input
                }], maxTagLength: [{
                    type: i0.Input
                }], maxNumberOfTags: [{
                    type: i0.Input
                }], textChange: [{
                    type: i0.Output
                }], handleClick: [{
                    type: i0.HostListener,
                    args: ['document:click', ['$event']]
                }] } });
    function formatter(tag) {
        return tag
            .trim()
            .replace(/(\s|-)+/g, '-')
            .replace(/\,/g, '')
            .toLowerCase();
    }

    var NgxInputTagModule = /** @class */ (function () {
        function NgxInputTagModule() {
        }
        NgxInputTagModule.forRoot = function (config) {
            if (config === void 0) { config = { tagFormatter: formatter }; }
            return {
                ngModule: NgxInputTagModule,
                providers: [
                    {
                        provide: NGX_INPUT_TAG_TAG_FORMATTER,
                        useValue: config.tagFormatter,
                    },
                ],
            };
        };
        return NgxInputTagModule;
    }());
    NgxInputTagModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0__namespace, type: NgxInputTagModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    NgxInputTagModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0__namespace, type: NgxInputTagModule, declarations: [NgxInputTagComponent], imports: [i1.CommonModule], exports: [NgxInputTagComponent] });
    NgxInputTagModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0__namespace, type: NgxInputTagModule, imports: [[i1.CommonModule]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0__namespace, type: NgxInputTagModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [i1.CommonModule],
                        declarations: [NgxInputTagComponent],
                        exports: [NgxInputTagComponent],
                    }]
            }] });

    /*
     * Public API Surface of ngx-input-tag
     */

    /**
     * Generated bundle index. Do not edit.
     */

    exports.NGX_INPUT_TAG_TAG_FORMATTER = NGX_INPUT_TAG_TAG_FORMATTER;
    exports.NgxInputTagComponent = NgxInputTagComponent;
    exports.NgxInputTagModule = NgxInputTagModule;
    exports.formatter = formatter;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=ngx-lite-input-tag.umd.js.map
